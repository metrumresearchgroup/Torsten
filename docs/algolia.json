[{"content":"Institutions We thank Metrum Research Group, Columbia University, and AstraZeneca.\nFunding This work was funded in part by the following organizations:\nOffice of Naval Research (ONR) contract N00014-16-P-2039 provided as part of the Small Business Technology Transfer (STTR) program. The content of the information presented in this document does not necessarily reflect the position or policy of the Government and no official endorsement should be inferred.\nBill \u0026amp;amp; Melinda Gates Foundation. Individuals We thank the Stan Development Team for giving us guidance on how to create new Stan functions and adding features to Stan\u0026amp;rsquo;s core language that facilitate building ODE-based models.\nWe also thank Kyle Baron and Hunter Ford for helpful advice on coding in C++ and using GitHub, Curtis Johnston for reviewing the User Manual, and Yaming Su for using Torsten and giving us feedback.\n","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:17-07:00","objectID":"48b7717594b9b32e0181247bfc17a434","permalink":"https://metrumresearchgroup.github.io/Torsten/acknowledgements/","publishdate":"2021-06-25T00:00:00-07:00","title":"Acknowledgements"},{"content":"  Version 0.89 \u0026amp;lt;2021-06-15 Tue\u0026amp;gt;\n Changed  New backend for ODE events solvers. Use vector instead of array as ODE function state \u0026amp;amp; return type. Simplified ODE integrator naming, e.g. pmx_ode_bdf[_ctrl]. Update to Stan version 2.27.0.      Version 0.88 \u0026amp;lt;2020-12-18 Fri\u0026amp;gt;\n Added  Bioavailability, lag time, ODE real \u0026amp;amp; integer data are optional in PMX function signatures. Support all EVID options from NM-TRAN and mrgsolve. Support steady-state infusion through multiple interdose intervals.      Changed  More efficient memory management of COVDES implenmentation. Update of MPI framework to adapt multilevel paralleism. Update to Stan version 2.25.0. Use cmdstanr as R interface. Stop supporting rstan as R interface.      Version 0.87 \u0026amp;lt;2019-07-26 Fri\u0026amp;gt;\n Added   MPI dynamic load balance for Torsten\u0026amp;rsquo;s population ODE integrators\n pmx_integrate_ode_group_adams pmx_integrate_ode_group_bdf pmx_integrate_ode_group_rk45  To invoke dynamic load balance instead of default static balance for MPI, issue TORSTEN_MPI=2 in make/local.\n  Support RATE as parameter in pmx_solve_rk45/bdf/adams functions.\n   Changed  Some fixes on steady-state solvers Update to rstan version 2.19.2.      Version 0.86 \u0026amp;lt;2019-05-15 Wed\u0026amp;gt;\n Added   Torsten\u0026amp;rsquo;s ODE integrator functions\n pmx_integrate_ode_adams pmx_integrate_ode_bdf pmx_integrate_ode_rk45  and their counterparts to solve a population/group of subjects governed by an ODE\n pmx_integrate_ode_group_adams pmx_integrate_ode_group_bdf pmx_integrate_ode_group_rk45    Torsten\u0026amp;rsquo;s population PMX solver functions for general ODE models\n pmx_solve_group_adams pmx_solve_group_bdf pmx_solve_group_rk45    Support time step ts as parameter in pmx_integrate_ode_xxx solvers.\n   Changed   Renaming Torsten functions in previous releases, the old-new name mapping is\n PKModelOneCpt → pmx_solve_onecpt PKModelTwoCpt → pmx_solve_onecpt linOdeModel → pmx_solve_linode generalOdeModel_adams → pmx_solve_adams generalOdeModel_bdf → …","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:19-07:00","objectID":"9b8fab691c00b9e5380b19ce882f3271","permalink":"https://metrumresearchgroup.github.io/Torsten/changelog/","publishdate":"2021-06-25T00:00:00-07:00","title":"Changelog"},{"content":"Our current plans for future development of Torsten include the following:\n Build a system to easily share packages of Stan functions (written in C++ or in the Stan language) Optimize Matrix exponential functions  Function for the action of Matrix Exponential on a vector Hand-coded gradients Special algorithm for matrices with special properties   Develop new method for large-scale hierarchical models with costly ODE solving. Fix issue that arises when computing the adjoint of the lag time parameter (in a dosing compartment) evaluated at \\(t_{\\text{lag}} = 0\\). Extend formal tests  More unit tests and better CD/CI support. Comparison with simulations from the R package mrgsolve and the software NONMEM\\textregistered{} Recruit non-developer users to conduct beta testing    ","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:18-07:00","objectID":"f15db80307ad89082c4d649f349f2279","permalink":"https://metrumresearchgroup.github.io/Torsten/development-plans/","publishdate":"2021-06-25T00:00:00-07:00","title":"Development plans"},{"content":" Current Torsten v0.89rc is based on Stan v2.27.0. All functions are programmed in C++ and are compatible with the Stan math automatic differentiation library (Carpenter et al. 2015) One and two compartment models are based on analytical solutions of governing ODEs. General linear compartment models are based on semi-analytical solutions using the built-in matrix exponential function General compartment models are solved numerically using built-in ODE integrators in Stan. The tuning parameters of the solver are adjustable. The steady state solution is calculated using a numerical algebraic solver. Coupled model that has PK forcing function solved analytically and PD ODE components solved numerically.  1 Bibliography Carpenter, Bob, Matthew D. Hoffman, Marcus Brubaker, Daniel Lee, Peter Li, and Michael Betancourt. 2015. “The Stan Math Library: Reverse-Mode Automatic Differentiation in C++.” arXiv:1509.07164 [Cs], September. http://arxiv.org/abs/1509.07164.\n","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:18-07:00","objectID":"8b432e5a35deedf3ef66acda36cb2ae3","permalink":"https://metrumresearchgroup.github.io/Torsten/implementation-summary/","publishdate":"2021-06-25T00:00:00-07:00","title":"Implementation summary"},{"content":"Currently Torsten is based on a forked version of Stan and hosted on GitHub\n https://github.com/metrumresearchgroup/Torsten  The latest v0.89rc is compatible with Stan v2.27.0. Torsten can be accessed from command line for cmdstan interface and cmdstanr (https://mc-stan.org/cmdstanr/) for R interface. It requires a modern C++11 compiler as well as a Make utility. See (Team 2020) for details of installation and required toolchain. In particular, we recommend the folowing versions of C++ compilers:\n Linux: g++ \u0026amp;gt;=7.5 or clang \u0026amp;gt;=8.0, macOS: the XCode version of clang, Windows: g++ 8.1 (available with RTools 4.0).  On windows, the Make utility mingw32-make can be installed as part of RTools.\nCommand line interface The command line interface cmdstan is available along with Torsten and can be found at Torsten/cmdstan.\nAfter installation, one can use the following command to build a Torsten model model_name in model_path\ncd Torsten/cmdstan make model_path/model_name # replace \u0026amp;#34;make\u0026amp;#34; with \u0026amp;#34;mingw32-make\u0026amp;#34; on Windows platform R interface After installing cmdstanr from https://mc-stan.org/cmdstanr/, use the following command to set path\ncmdstanr::set_cmdstan_path(\u0026amp;#34;Torsten/cmdstan\u0026amp;#34;) Then one can follow https://mc-stan.org/cmdstanr/articles/cmdstanr.html to compile and run Torsten models.\nMPI support Torsten\u0026amp;rsquo;s MPI support is of a different flavour than reduce_sum found in Stan. To be able to utilize MPI parallelisation, one first needs to ensure an MPI library such as\n https://www.mpich.org/downloads/ https://www.open-mpi.org/software/ompi/  is available. Torsen\u0026amp;rsquo;s implementation is tested on both MPICH and OpenMPI.\nTo use MPI-supported population/group solvers, add/edit make/local\nTORSTEN_MPI=1 # path to MPI headers CXXFLAGS += -isystem /usr/local/include # if you are using Metrum\u0026amp;#39;s metworx platform, add MPICH3\u0026amp;#39;s # headers with # CXXFLAGS += -isystem /usr/local/mpich3/include Note that currently TORSTEN_MPI and STAN_MPI flags …","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:20-07:00","objectID":"ed910981ef0746b8d8e60712cad092ca","permalink":"https://metrumresearchgroup.github.io/Torsten/installation/","publishdate":"2021-06-25T00:00:00-07:00","title":"Installation"},{"content":"Torsten is a collection of Stan functions to facilitate analysis of pharmacometric data using Stan. The current version includes:\n Specific linear compartment models:  One compartment model with first order absorption. Two compartment model with elimination from and first order absorption into central compartment   General linear compartment model described by a system of first-order \\underline{linear} Ordinary Differential Equations (ODEs). General compartment model described by a system of first order ODEs. Mix compartment model with PK forcing function described by a linear one or two compartment model.  The models and data format are based on NONMEM\\textregistered{}1/NMTRAN/PREDPP conventions including:\n Recursive calculation of model predictions  This permits piecewise constant covariate values   Bolus or constant rate inputs into any compartment Single dose and multiple dose events Handles steady state dosing events Implemented NMTRAN data items include: TIME, EVID, CMT, AMT, RATE, ADDL, II, SS  In general, all real variables may be passed as model parameters. A few exceptions apply /to functions which use a numerical integrator(i.e. the general and the mix compartment models). The below listed cases present technical difficulties, which we expect to overcome in Torsten\u0026amp;rsquo;s next release:\n In the case of a multiple truncated infusion rate dosing regimen:  The bioavailability (F) and the amount (AMT) must be fixed.    This library provides Stan language functions that calculate amounts in each compartment, given an event schedule and an ODE system.\n  NONMEM\\textregistered{} is licensed and distributed by ICON Development Solutions.\u0026amp;#160;\u0026amp;#x21a9;\u0026amp;#xfe0e;\n   ","date":1624604400,"description":"","lastmod":"2021-06-28T19:35:09-07:00","objectID":"c2657ed3c67696058d106c17264485ae","permalink":"https://metrumresearchgroup.github.io/Torsten/overview/","publishdate":"2021-06-25T00:00:00-07:00","title":"Overview"},{"content":"Stan is an open source probabilistic programing language designed primarily to do Bayesian data analysis (Carpenter et al. 2017). It provides an expressive syntax for statistic modeling and contains an efficient variant of No U-Turn Sampler(NUTS), an adaptative Hamiltonian Monte Carlo algorithm that was proven more efficient than commonly used Monte Carlo Markov Chains (MCMC) samplers for complex high dimensional problems (Hoffman and Gelman 2011; Betancourt 2018).\n Torsten is a collection of Stan functions to facilitate analysis of pharmacometric data. Given an event schedule and an ODE system, it calculates amounts in each compartment. The current version includes 1:\n Specific linear compartment models:  One compartment model with first order absorption. Two compartment model with elimination from and first order absorption into central compartment   General linear compartment model described by a system of first-order linear Ordinary Differential Equations (ODEs). General compartment model described by a system of first order ODEs. Coupled model with PK forcing function described by a linear one or two compartment model and PD components solved by numerical ODE integration.  The models and data format are based on NONMEM \\textregistered{} 2/NMTRAN/PREDPP conventions including:\n recursive calculation of model predictions, which permits piecewise constant covariate values, bolus or constant rate inputs into any compartment, single dose and multiple dose events, steady state dosing events, NMTRAN-compartible data items such as TIME, EVID, CMT, AMT, RATE, ADDL, II, and SS.  All real variable arguments in Torsten functions can be passed as Stan parameters.\nImplementation summary  Current Torsten v0.89rc is based on Stan v2.27.0. All functions are programmed in C++ and are compatible with the Stan math automatic differentiation library (Carpenter et al. 2015) One and two compartment models are based on analytical solutions of governing ODEs. General linear compartment …","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:17-07:00","objectID":"3976528693a0108357f4928017600865","permalink":"https://metrumresearchgroup.github.io/Torsten/","publishdate":"2021-06-25T00:00:00-07:00","title":"Introduction"},{"content":" William R. Gillespie , Metrum Research Group Yi Zhang , Metrum Research Group Charles Margossian , Columbia University, Department of Statistics  ","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:16-07:00","objectID":"5c3c25f82b6d43f60dfab830997807f1","permalink":"https://metrumresearchgroup.github.io/Torsten/dev-team/","publishdate":"2021-06-25T00:00:00-07:00","title":"Development team"},{"content":"integral of a quadratic function. This example shows how to use univariate_integral_rk45 to calculate the integral of a quadratic function.\nfunctions { real fun_ord2(real t, real[] theta, real[] x_r, int[] x_i) { real a = 2.3; real b = 2.0; real c = 1.5; real res; res = a + b * t + c * t * t; return res; } } data { real t0; real t1; real dtheta[2]; real x_r[0]; int x_i[0]; } transformed data { real univar_integral; univar_integral = univariate_integral_rk45(func, t0, t1, dtheta, x_r, x_i); } /* ... */ ","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:34-07:00","objectID":"b7a16b6b7d2655f9bbcde87aa7a24e20","permalink":"https://metrumresearchgroup.github.io/Torsten/example/1d-intg/","publishdate":"2021-06-25T00:00:00-07:00","title":"Univariate integral of a quadratic function"},{"content":"All the PMX models in this chapter can be found in Torsten/example-models directory:\n Two-compartment model Two-compartment model by linear ODEs two-compartment model by numerical ODEs Joint PK/PD model Two-compartment popPK model Group of ODEs Effective compartment model PopPKPD model  ","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:30-07:00","objectID":"433d5129a667ddc5fb439ec172a8745c","permalink":"https://metrumresearchgroup.github.io/Torsten/example/","publishdate":"2021-06-25T00:00:00-07:00","title":"Examples"},{"content":" .ox-hugo-toc ul { list-style: none; }   Table of Contents  1 Population Model for Plasma Drug Concentration \\(c\\) 2 Effect Compartment Model for PD response \\(R\\). 3 Results    Here we expand the Two-compartment model for single patient to a population model fitted to the combined data from phase I and phase IIa studies. The parameters exhibit inter-individual variations (IIV), due to both random effects and to the patients\u0026#39; body weight, treated as a covariate and denoted \\(bw\\).\n1 Population Model for Plasma Drug Concentration \\(c\\) \\begin{gather*} \\log\\left(c_{ij}\\right) \\sim N\\left(\\log\\left(\\widehat{c}_{ij}\\right),\\sigma^2\\right), \\\\\\\n\\widehat{c}_{ij} = f_{2cpt}\\left(t_{ij},D_j,\\tau_j,CL_j,Q_j,V_{1j},V_{2j},k_{aj}\\right), \\\\\\\n\\log\\left(CL_j,Q_j,V_{ssj},k_{aj}\\right) \\sim N\\left(\\log\\left(\\widehat{CL}\\left(\\frac{bw_j}{70}\\right)^{0.75},\\widehat{Q}\\left(\\frac{bw_j}{70}\\right)^{0.75}, \\widehat{V}_{ss}\\left(\\frac{bw_j}{70}\\right),\\widehat{k}_a\\right),\\Omega\\right), \\\\\\\nV_{1j} = f_{V_1}V_{ssj}, \\\\\\\nV_{2j} = \\left(1 - f_{V_1}\\right)V_{ssj}, \\\\\\\n\\left(\\widehat{CL},\\widehat{Q},\\widehat{V}_{ss},\\widehat{k}_a, f_{V_1}\\right) = \\left(10\\ {\\rm L/h},15\\ {\\rm L/h},140\\ {\\rm L},2\\ {\\rm h^{-1}}, 0.25 \\right), \\\\\\\n\\Omega = \\left(\\begin{array}{cccc} 0.25^2 \u0026amp;amp; 0 \u0026amp;amp; 0 \u0026amp;amp; 0 \\ 0 \u0026amp;amp; 0.25^2 \u0026amp;amp; 0 \u0026amp;amp; 0 \\\\\\\n0 \u0026amp;amp; 0 \u0026amp;amp; 0.25^2 \u0026amp;amp; 0 \\ 0 \u0026amp;amp; 0 \u0026amp;amp; 0 \u0026amp;amp; 0.25^2 \\end{array}\\right), \\\\\\\n\\sigma = 0.1 \\end{gather*}\nFurthermore we add a fourth compartment in which we measure a PD effect(Figure 1).\n\n Figure 1: Effect Compartment Model\n  2 Effect Compartment Model for PD response \\(R\\). \\begin{gather*} R_{ij} \\sim N\\left(\\widehat{R}_{ij},\\sigma_{R}^2\\right), \\\\\\\n\\widehat{R}_{ij} = \\frac{E_{max}c_{eij}}{EC_{50j} + c_{eij}}, \\\\\\\nc_{e\\cdot j}^\\prime = k_{e0j}\\left(c_{\\cdot j} - c_{e\\cdot j}\\right), \\\\\\\n\\log\\left(EC_{50j}, k_{e0j}\\right) \\sim N\\left(\\log\\left(\\widehat{EC}_{50}, \\widehat{k}_{e0}\\right),\\Omega_R\\right), \\\\\\\n\\left(E_{max}, …","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:35-07:00","objectID":"c940d55dcfa63e020606ed330e1533aa","permalink":"https://metrumresearchgroup.github.io/Torsten/example/effcpt/","publishdate":"2021-06-25T00:00:00-07:00","title":"Effect Compartment Population Model"},{"content":"This example illustrates how to use linear_intepolationi to fit a piecewise linear function to a data set consisting of \\((x, y)\\) pairs.\ndata{ int nObs; real xObs[nObs]; real yObs[nObs]; int nx; int nPred; real xPred[nPred]; } transformed data{ real xmin = min(xObs); real xmax = max(xObs); } parameters{ real y[nx]; real\u0026amp;lt;lower = 0\u0026amp;gt; sigma; simplex[nx - 1] xSimplex; } transformed parameters{ real yHat[nObs]; real x[nx]; x[1] = xmin; x[nx] = xmax; for(i in 2:(nx-1)) x[i] = x[i-1] + xSimplex[i-1] * (xmax - xmin); yHat = linear_interpolation(xObs, x, y); } model{ xSimplex ~ dirichlet(rep_vector(1, nx - 1)); y ~ normal(0, 25); yObs ~ normal(yHat, sigma); } generated quantities{ real yHatPred[nPred]; real yPred[nPred]; yHatPred = linear_interpolation(xPred, x, y); for(i in 1:nPred) yPred[i] = normal_rng(yHatPred[i], sigma); } ","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:34-07:00","objectID":"ca1fa6dab02d48d5f251fe1d6ba5c909","permalink":"https://metrumresearchgroup.github.io/Torsten/example/lin-interp/","publishdate":"2021-06-25T00:00:00-07:00","title":"Linear intepolation"},{"content":"Using pmx_integrate_ode_group_rk45, the following example fits a Lotka-Volterra group model, based on Stan\u0026amp;rsquo;s case study.\nfunctions { real[] dz_dt(real t, // time real[] z, // system state {prey, predator} real[] theta, // parameters real[] x_r, // unused data int[] x_i) { real u = z[1]; real v = z[2]; real alpha = theta[1]; real beta = theta[2]; real gamma = theta[3]; real delta = theta[4]; real du_dt = (alpha - beta * v) * u; real dv_dt = (-gamma + delta * u) * v; return { du_dt, dv_dt }; } } data { int\u0026amp;lt;lower = 0\u0026amp;gt; N_subj; // number of subjects int\u0026amp;lt;lower = 0\u0026amp;gt; N; // number of measurement times real ts_0[N]; // measurement times \u0026amp;gt; 0 real y0_0[2]; // initial measured populations real\u0026amp;lt;lower = 0\u0026amp;gt; y_0[N, 2]; // measured populations } transformed data { int len[N_subj] = rep_array(N, N_subj); real y0[N_subj, 2] = rep_array(y0_0, N_subj); real y[N_subj, N, 2] = rep_array(y_0, N_subj); real ts[N_subj * N]; for (i in 1:N_subj) { ts[((i-1)*N + 1) : (i*N)] = ts_0; } } parameters { real\u0026amp;lt;lower = 0\u0026amp;gt; theta[N_subj, 4]; // { alpha, beta, gamma, delta } real\u0026amp;lt;lower = 0\u0026amp;gt; z_init[N_subj, 2]; // initial population real\u0026amp;lt;lower = 0\u0026amp;gt; sigma[N_subj, 2]; // measurement errors } transformed parameters { matrix[2, N_subj * N] z; z = pmx_integrate_ode_group_rk45(dz_dt, z_init, 0, len, ts, theta, rep_array(rep_array(0.0, 0), N_subj), rep_array(rep_array(0, 0),N_subj)); } model { for (isub in 1:N_subj) { theta[isub, {1, 3}] ~ normal(1, 0.5); theta[isub, {2, 4}] ~ normal(0.05, 0.05); sigma[isub] ~ lognormal(-1, 1); z_init[isub] ~ lognormal(10, 1); for (k in 1:2) { y0[isub, k] ~ lognormal(log(z_init[isub, k]), sigma[isub, k]); y[isub, , k] ~ lognormal(log(z[k, ((isub-1)*N + 1):(isub*N)]), sigma[isub, k]); } } ","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:33-07:00","objectID":"92c7e5d9c8ac0b0ae7133ac113ba44b1","permalink":"https://metrumresearchgroup.github.io/Torsten/example/ode-group/","publishdate":"2021-06-25T00:00:00-07:00","title":"Lotka-Volterra group model"},{"content":" .ox-hugo-toc ul { list-style: none; }   Table of Contents  1 Friberg-Karlsson Population Model for drug-induced myelosuppression (\\(ANC\\)) 2 Results    We now return to the example of Joint PK-PD model and extend it to a population model. While we recommend using the coupled solver, and this time we solve it using group solver. We leave it as an exercise to the reader to rewrite the model with coupled solver.\n1 Friberg-Karlsson Population Model for drug-induced myelosuppression (\\(ANC\\)) \\begin{gather*} \\log(ANC_{ij}) \\sim N(Circ_{ij}, \\sigma^2_{ANC}), \\\\\\\n\\log\\left(MTT_j, Circ_{0j}, \\alpha_j\\right) \\sim N\\left(\\log\\left(\\widehat{MTT}, \\widehat{Circ_0}, \\widehat{\\alpha}\\right), \\Omega_{ANC}\\right), \\\\\\\n\\left(\\widehat{MTT}, \\widehat{Circ}_0,\\widehat{\\alpha}, \\gamma \\right) = \\left(125, 5, 2, 0.17\\right), \\\\\\\n\\Omega_{ANC} = \\left(\\begin{array}{ccc} 0.2^2 \u0026amp;amp; 0 \u0026amp;amp; 0 \\ 0 \u0026amp;amp; 0.35^2 \u0026amp;amp; 0 \\ 0 \u0026amp;amp; 0 \u0026amp;amp; 0.2^2 \\end{array}\\right), \\\\\\\n\\sigma_{ANC} = 0.1, \\\\\\\n\\Omega_{PK} = \\left(\\begin{array}{ccccc} 0.25^2 \u0026amp;amp; 0 \u0026amp;amp;a 0 \u0026amp;amp; 0 \u0026amp;amp; 0 \\ 0 \u0026amp;amp; 0.4^2 \u0026amp;amp; 0 \u0026amp;amp; 0 \u0026amp;amp; 0 \\\\\\\n0 \u0026amp;amp; 0 \u0026amp;amp; 0.25^2 \u0026amp;amp; 0 \u0026amp;amp; 0 \\ 0 \u0026amp;amp; 0 \u0026amp;amp; 0 \u0026amp;amp; 0.4^2 \u0026amp;amp; 0 \\ 0 \u0026amp;amp; 0 \u0026amp;amp; 0 \u0026amp;amp; 0 \u0026amp;amp; 0.25^2 \\end{array}\\right) \\end{gather*}\nThe PK and the PD data are simulated using the following treatment.\n Phase IIa trial in patients  Multiple doses: 80,000 mg Parallel dose escalation design 15 subjects PK: plasma concentration of parent drug (\\(c\\)) PD response: Neutrophil count (\\(ANC\\)) PK measured at 0.083, 0.167, 0.25, 0.5, 0.75, 1, 2, 3, 4, 6, 8, 12, 18, and 24 hours PD measured once every two days for 28 days.    Once again, we simultaneously fit the model to the PK and the PD data. It pays off to construct informative priors. For instance, we could fit the PK data first, as was done in example 1, and get informative priors on the PK parameters. The PD parameters are drug independent, so we can use information from the neutropenia literature. In this example, …","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:35-07:00","objectID":"ba2de53bc5cba223bf60e51c4117bd64","permalink":"https://metrumresearchgroup.github.io/Torsten/example/pkpd-pop/","publishdate":"2021-06-25T00:00:00-07:00","title":"Friberg-Karlsson Semi-Mechanistic Population Model"},{"content":" .ox-hugo-toc ul { list-style: none; }   Table of Contents  1 Bibliography    Neutropenia is observed in patients receiving an ME-2 drug. Our goal is to model the relation between neutrophil counts and drug exposure. As shown in Figure 1, the Friberg-Karlsson Semi-Mechanistic model (Friberg and Karlsson 2003) couples a PK model with a PD effect to describe a delayed feedback mechanism that keeps the absolute neutrophil count (ANC) at the baseline in a circulatory compartment (Circ), and the drug\u0026amp;rsquo;s effect in reducing the proliferation rate (prol). The delay between prol and Circ is modeled using \\(n\\) transit comparments with mean transit time MTT = \\((n + 1)/k_{\\text{tr}}\\), with \\(k_{\\text{tr}}\\) the transit rate constant. In the current example, we use the Two Compartment Model for PK model, and set \\(n = 3\\).\n\\begin{align} \\log(\\text{ANC})\u0026amp;amp; \\sim N(\\log(y_{\\text{circ}}), \\sigma^2_{\\text{ANC}}), \\\\\\\ny_{\\text{circ}}\u0026amp;amp; = f_{\\text{FK}}(\\text{MTT}, \\text{Circ}_{0}, \\alpha, \\gamma, c), \\end{align}\nwhere \\(c\\) is the drug concentration calculated from the PK model, and function \\(f_{\\text{FK}}\\) represents solving the following nonlinear ODE for \\(y_{\\text{circ}}\\)\n\\begin{align}\\label{eq:FK} \\frac{dy_\\mathrm{prol}}{dt} \u0026amp;amp;= k_\\mathrm{prol} y_\\mathrm{prol} (1 - E_\\mathrm{drug})\\left(\\frac{\\text{Circ}_0}{y_\\mathrm{circ}}\\right)^\\gamma - k_\\mathrm{tr}y_\\mathrm{prol}, \\\\\\\n\\frac{dy_\\mathrm{trans1}}{dt} \u0026amp;amp;= k_\\mathrm{tr} y_\\mathrm{prol} - k_\\mathrm{tr} y_\\mathrm{trans1}, \\\\\\\n\\frac{dy_\\mathrm{trans2}}{dt} \u0026amp;amp;= k_\\mathrm{tr} y_\\mathrm{trans1} - k_\\mathrm{tr} y_\\mathrm{trans2}, \\\\\\\n\\frac{dy_\\mathrm{trans3}}{dt} \u0026amp;amp;= k_\\mathrm{tr} y_\\mathrm{trans2} - k_\\mathrm{tr} y_\\mathrm{trans3}, \\\\\\\n\\frac{dy_\\mathrm{circ}}{dt} \u0026amp;amp;= k_\\mathrm{tr} y_\\mathrm{trans3} - k_\\mathrm{tr} y_\\mathrm{circ}, \\end{align}\nWe use \\(E_{\\text{drug}} = \\alpha c\\) to model the linear effect of drug concentration in central compartment, with \\(c=y_{\\text{cent}}/V_{\\text{cent}}\\) based on PK …","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:32-07:00","objectID":"647587399a7f56c9225520ae44516210","permalink":"https://metrumresearchgroup.github.io/Torsten/example/pkpd/","publishdate":"2021-06-25T00:00:00-07:00","title":"Joint PK-PD model"},{"content":"Using pmx_solve_group_bdf, the following example fits a two-compartment population model.\nfunctions{ // define ODE system for two compartmnt model real[] twoCptModelODE(real t, real[] x, real[] parms, real[] rate, // in this example, rate is treated as data int[] dummy){ // Parameters real CL = parms[1]; real Q = parms[2]; real V1 = parms[3]; real V2 = parms[4]; real ka = parms[5]; // Re-parametrization real k10 = CL / V1; real k12 = Q / V1; real k21 = Q / V2; // Return object (derivative) real y[3]; // 1 element per compartment of // the model // PK component of the ODE system y[1] = -ka*x[1]; y[2] = ka*x[1] - (k10 + k12)*x[2] + k21*x[3]; y[3] = k12*x[2] - k21*x[3]; return y; } } data{ int\u0026amp;lt;lower = 1\u0026amp;gt; np; /* population size */ int\u0026amp;lt;lower = 1\u0026amp;gt; nt; // number of events int\u0026amp;lt;lower = 1\u0026amp;gt; nObs; // number of observations int\u0026amp;lt;lower = 1\u0026amp;gt; iObs[nObs]; // index of observation // NONMEM data int\u0026amp;lt;lower = 1\u0026amp;gt; cmt[np * nt]; int evid[np * nt]; int addl[np * nt]; int ss[np * nt]; real amt[np * nt]; real time[np * nt]; real rate[np * nt]; real ii[np * nt]; real\u0026amp;lt;lower = 0\u0026amp;gt; cObs[np*nObs]; // observed concentration (dependent variable) } transformed data { real logCObs[np*nObs]; int\u0026amp;lt;lower = 1\u0026amp;gt; len[np]; int\u0026amp;lt;lower = 1\u0026amp;gt; len_theta[np]; int\u0026amp;lt;lower = 1\u0026amp;gt; len_biovar[np]; int\u0026amp;lt;lower = 1\u0026amp;gt; len_tlag[np]; int nTheta = 5; // number of parameters int nCmt = 3; // number of compartments real biovar[np * nt, nCmt]; real tlag[np * nt, nCmt]; logCObs = log(cObs); for (id in 1:np) { for (j in 1:nt) { for (i in 1:nCmt) { biovar[(id - 1) * nt + j, i] = 1; tlag[(id - 1) * nt + j, i] = 0; } } len[id] = nt; len_theta[id] = nt; len_biovar[id] = nt; len_tlag[id] = nt; } } parameters{ real\u0026amp;lt;lower = 0\u0026amp;gt; CL[np]; real\u0026amp;lt;lower = 0\u0026amp;gt; Q[np]; real\u0026amp;lt;lower = 0\u0026amp;gt; V1[np]; real\u0026amp;lt;lower = 0\u0026amp;gt; V2[np]; real\u0026amp;lt;lower = 0\u0026amp;gt; ka[np]; real\u0026amp;lt;lower = 0\u0026amp;gt; sigma[np]; } transformed parameters{ real theta[np * nt, nTheta]; vector\u0026amp;lt;lower = 0\u0026amp;gt;[nt] cHat[np]; …","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:33-07:00","objectID":"80a90c87379fe7ca9b6a5a63a123e910","permalink":"https://metrumresearchgroup.github.io/Torsten/example/twocp-pop/","publishdate":"2021-06-25T00:00:00-07:00","title":"Two-compartment population model"},{"content":"Using pmx_solve_linode, the following example fits a two-compartment model with first order absorption. We omit data and model block as they are identical to Two-compartment model for single patient Example.\ntransformed data{ row_vector[nObs] logCObs = log(cObs); int nCmt = 3; real biovar[nCmt]; real tlag[nCmt]; for (i in 1:nCmt) { biovar[i] = 1; tlag[i] = 0; } } parameters{ real\u0026amp;lt;lower = 0\u0026amp;gt; CL; real\u0026amp;lt;lower = 0\u0026amp;gt; Q; real\u0026amp;lt;lower = 0\u0026amp;gt; V1; real\u0026amp;lt;lower = 0\u0026amp;gt; V2; real\u0026amp;lt;lower = 0\u0026amp;gt; ka; real\u0026amp;lt;lower = 0\u0026amp;gt; sigma; } transformed parameters{ matrix[3, 3] K; real k10 = CL / V1; real k12 = Q / V1; real k21 = Q / V2; row_vector\u0026amp;lt;lower = 0\u0026amp;gt;[nt] cHat; row_vector\u0026amp;lt;lower = 0\u0026amp;gt;[nObs] cHatObs; matrix\u0026amp;lt;lower = 0\u0026amp;gt;[3, nt] x; K = rep_matrix(0, 3, 3); K[1, 1] = -ka; K[2, 1] = ka; K[2, 2] = -(k10 + k12); K[2, 3] = k21; K[3, 2] = k12; K[3, 3] = -k21; x = pmx_solve_linode(time, amt, rate, ii, evid, cmt, addl, ss, K, biovar, tlag); cHat = row(x, 2) ./ V1; for(i in 1:nObs){ cHatObs[i] = cHat[iObs[i]]; // predictions for observed data records } } ","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:31-07:00","objectID":"fde44266b6f233d377ce359904d29fb7","permalink":"https://metrumresearchgroup.github.io/Torsten/example/twocpt-lin/","publishdate":"2021-06-25T00:00:00-07:00","title":"Two-compartment model as a linear ODE model for single patient"},{"content":"Using pmx_solve_rk45, the following example fits a two-compartment model with first order absorption. User-defined function ode_rhs describes the RHS of the ODEs.\nfunctions{ vector ode_rhs(real t, vector x, real[] parms, real[] x_r, int[] x_i){ real CL = parms[1]; real Q = parms[2]; real V1 = parms[3]; real V2 = parms[4]; real ka = parms[5]; real k10 = CL / V1; real k12 = Q / V1; real k21 = Q / V2; vector[3] y; y[1] = -ka*x[1]; y[2] = ka*x[1] - (k10 + k12)*x[2] + k21*x[3]; y[3] = k12*x[2] - k21*x[3]; return y; } } We omit data and model block as they are identical to Two-compartment model for single patient Example.\ntransformed data { row_vector[nObs] logCObs = log(cObs); int nTheta = 5; // number of parameters int nCmt = 3; // number of compartments } parameters { real\u0026amp;lt;lower = 0\u0026amp;gt; CL; real\u0026amp;lt;lower = 0\u0026amp;gt; Q; real\u0026amp;lt;lower = 0\u0026amp;gt; V1; real\u0026amp;lt;lower = 0\u0026amp;gt; V2; real\u0026amp;lt;lower = 0\u0026amp;gt; ka; real\u0026amp;lt;lower = 0\u0026amp;gt; sigma; } transformed parameters { real theta[nTheta]; row_vector\u0026amp;lt;lower = 0\u0026amp;gt;[nt] cHat; row_vector\u0026amp;lt;lower = 0\u0026amp;gt;[nObs] cHatObs; matrix\u0026amp;lt;lower = 0\u0026amp;gt;[3, nt] x; theta[1] = CL; theta[2] = Q; theta[3] = V1; theta[4] = V2; theta[5] = ka; x = pmx_solve_rk45(ode_rhs, 3, time, amt, rate, ii, evid, cmt, addl, ss, theta, 1e-5, 1e-8, 1e5); cHat = x[2, ] ./ V1; for(i in 1:nObs){ cHatObs[i] = cHat[iObs[i]]; // predictions for observed data records } } model{ ","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:31-07:00","objectID":"e24429d0fcf9f36844321f9ba0f23d34","permalink":"https://metrumresearchgroup.github.io/Torsten/example/twocpt-ode/","publishdate":"2021-06-25T00:00:00-07:00","title":"Two-compartment model solved by numerical integrator for single patient"},{"content":"We model drug absorption in a single patient and simulate plasma drug concentrations:\n Multiple Doses: 1250 mg, every 12 hours, for a total of 15 doses PK measured at 0.083, 0.167, 0.25, 0.5, 0.75, 1, 1.5, 2, 4, 6, 8, 10 and 12 hours after 1st, 2nd, and 15th dose. In addition, the PK is measured every 12 hours throughout the trial.  With the plasma concentration \\(\\hat{c}\\) using Two Compartment Model, we simulate \\(c\\) according to:\n\\begin{align*} \\log\\left(c\\right) \u0026amp;amp;\\sim N\\left(\\log\\left(\\widehat{c}\\right),\\sigma^2\\right) \\\\\\\n\\left(CL, Q, V_2, V_3, ka\\right) \u0026amp;amp;= \\left(5\\ {\\rm L/h}, 8\\ {\\rm L/h}, 20\\ {\\rm L}, 70\\ {\\rm L}, 1.2\\ {\\rm h^{-1}} \\right) \\\\\\\n\\sigma^2 \u0026amp;amp;= 0.01 \\end{align*}\nThe data are generated using the R package mrgsolve (Baron and Gastonguay 2015).\nCode below shows how Torsten function pmx_solve_twocpt can be used to fit the above model.\ndata{ int\u0026amp;lt;lower = 1\u0026amp;gt; nt; // number of events int\u0026amp;lt;lower = 1\u0026amp;gt; nObs; // number of observation int\u0026amp;lt;lower = 1\u0026amp;gt; iObs[nObs]; // index of observation // NONMEM data int\u0026amp;lt;lower = 1\u0026amp;gt; cmt[nt]; int evid[nt]; int addl[nt]; int ss[nt]; real amt[nt]; real time[nt]; real rate[nt]; real ii[nt]; vector\u0026amp;lt;lower = 0\u0026amp;gt;[nObs] cObs; // observed concentration (Dependent Variable) } transformed data{ vector[nObs] logCObs = log(cObs); int nTheta = 5; // number of ODE parameters in Two Compartment Model int nCmt = 3; // number of compartments in model } parameters{ real\u0026amp;lt;lower = 0\u0026amp;gt; CL; real\u0026amp;lt;lower = 0\u0026amp;gt; Q; real\u0026amp;lt;lower = 0\u0026amp;gt; V1; real\u0026amp;lt;lower = 0\u0026amp;gt; V2; real\u0026amp;lt;lower = 0\u0026amp;gt; ka; real\u0026amp;lt;lower = 0\u0026amp;gt; sigma; } transformed parameters{ real theta[nTheta]; // ODE parameters row_vector\u0026amp;lt;lower = 0\u0026amp;gt;[nt] cHat; vector\u0026amp;lt;lower = 0\u0026amp;gt;[nObs] cHatObs; matrix\u0026amp;lt;lower = 0\u0026amp;gt;[nCmt, nt] x; theta[1] = CL; theta[2] = Q; theta[3] = V1; theta[4] = V2; theta[5] = ka; x = pmx_solve_twocpt(time, amt, rate, ii, evid, cmt, addl, ss, theta); cHat = x[2, :] ./ V1; // we\u0026#39;re interested in the amount in the second …","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:31-07:00","objectID":"0104ed48df7420c151295f469796da1b","permalink":"https://metrumresearchgroup.github.io/Torsten/example/twocpt/","publishdate":"2021-06-25T00:00:00-07:00","title":"Two-compartment model for single patient"},{"content":"real univariate_integral_rk45(f, t0, t1, theta, x_r, x_i) real univariate_integral_bdf(f, t0, t1, theta, x_r, x_i) Based on the ODE solver capability in Stan, Torsten provides functions calculating the integral of a univariate function. The integrand function \\(f\\) must follow the signature\nreal f(real t, real[] theta, real[] x_r, int[] x_i) { /* ... */ } ","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:28-07:00","objectID":"698d29e466b643ee83067af7ecf28a27","permalink":"https://metrumresearchgroup.github.io/Torsten/function/1d_integ/1d_integ/","publishdate":"2021-06-25T00:00:00-07:00","title":"Univariate integral"},{"content":"The reader should have a basic understanding of how Stan works. In this section we go through the different functions Torsten adds to Stan. The code for the examples can be found at Torsten\u0026amp;rsquo;s example models.\n0.1 Events specification Torsten\u0026amp;rsquo;s functions are prefixed with pmx_. For some of their arguments we adopt NM-TRAN format for events specification(Table 1).\n\nTable 1: NM-TRAN compatible event specification arguments. All arrays should have the same length corresponding to the number of events.     Argument Name Definition Stan data type     time event time real[]   amt dosing amount real[]   rate infusion rate real[]   ii interdose interval real[]   evid event ID int[]   cmt event compartment int[]   addl additionial identical doses int[]   ss steady-state dosing flag int[]    All the real[] arguments above are allowed to be parameters in a Stan model. In addtion, Torsten functions support optional arguments and overloaded signatures. Optional arguments are indicated by surrounding square bracket []. Table below shows three commonly used PMX model arguments that support overloading. In the rest of this document we assume this convention unless indicated otherwise.\n\nTable 2: PMX model parameter overloadings. One can use 1d array real[] to indicate constants of all events, or 2d array real[ , ] so that the \\(i\\)th row of the array describes the model arguments for time interval \\((t_{i-1}, t_i)\\), and the number of the rows equals to the size of time.     Argument Name Definition Stan data type Optional     theta model parameters real[] or real[ , ] N   biovar bioavailability fraction real[] or real[ , ] Y (default to 1.0)   tlag lag time real[] or real[ , ] Y (default to 0.0)    ","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:22-07:00","objectID":"adf9f5b4dee9dc5127b813e9577a457d","permalink":"https://metrumresearchgroup.github.io/Torsten/function/","publishdate":"2021-06-25T00:00:00-07:00","title":"Using Torsten"},{"content":" .ox-hugo-toc ul { list-style: none; }   Table of Contents  1 Description 2 Usage 3 Arguments 4 Return value    1 Description When the ODE system consists of two subsystems in form of\n\\begin{align*} y_1^\\prime \u0026amp;amp;= f_1(t, y_1), \\\\\\\ny_2^\\prime \u0026amp;amp;= f_2(t, y_1, y_2), \\end{align*}\nwith \\(y_1\\), \\(y_2\\), \\(f_1\\), and \\(f_2\\) being vector-valued functions, and \\(y_1^\\prime\\) independent of \\(y_2\\), the solution can be accelerated if \\(y_1\\) admits an analytical solution which can be introduced into the ODE for \\(y_2\\) for numerical integration. This structure arises in PK/PD models, where \\(y_1\\) describes a forcing PK function and \\(y_2\\) the PD effects. In the example of a Friberg-Karlsson semi-mechanistic model(see below), we observe an average speedup of \\(\\sim 47 \\pm 18 %\\) when using the mix solver in lieu of the numerical integrator. In the context, currently the couple solver supports one- \u0026amp;amp; two-compartment for PK model, and rk45 \u0026amp;amp; bdf integrator for nonlinear PD model.\n2 Usage matrix pmx_solve_onecpt_[ rk45 || bdf ](reduced_ODE_system, int nOde, time, amt, rate, ii, evid, cmt, addl, ss, theta, biovar, tlag [, real rel_tol, real abs_tol, int max_step, real as_rel_tol, real as_abs_tol, int as_max_step ] ); matrix pmx_solve_twocpt_[ rk45 || bdf ](reduced_ODE_system, int nOde, time, amt, rate, ii, evid, cmt, addl, ss, theta, biovar, tlag [, real rel_tol, real abs_tol, int max_step, real as_rel_tol, real as_abs_tol, int as_max_step ] ); 3 Arguments   reduced_ODE_rhs The system numerically solve (\\(y_2\\) in the above discussion, also called the reduced system and nOde the number of equations in the reduced system. The function that defines a reduced system has an almost identical signature to that used for a full system, but takes one additional argument: \\(y_1\\), the PK states, i.e. solution to the PK ODEs.\nvector reduced_ODE_rhs(real t, vector y2, vector y1, real[] theta, real[] x_r, int[] x_i)   nCmt The number of compartments. Equivalently, the …","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:26-07:00","objectID":"fd5f2c52e465dfa96899a2111e26b725","permalink":"https://metrumresearchgroup.github.io/Torsten/function/coupled/","publishdate":"2021-06-25T00:00:00-07:00","title":"Coupled ODE Model Function"},{"content":"Torsten\u0026amp;rsquo;s functions are prefixed with pmx_. For some of their arguments we adopt NM-TRAN format for events specification(Table 1).\n\nTable 1: NM-TRAN compatible event specification arguments. All arrays should have the same length corresponding to the number of events.     Argument Name Definition Stan data type     time event time real[]   amt dosing amount real[]   rate infusion rate real[]   ii interdose interval real[]   evid event ID int[]   cmt event compartment int[]   addl additionial identical doses int[]   ss steady-state dosing flag int[]    All the real[] arguments above are allowed to be parameters in a Stan model. In addtion, Torsten functions support optional arguments and overloaded signatures. Optional arguments are indicated by surrounding square bracket []. Table below shows three commonly used PMX model arguments that support overloading. In the rest of this document we assume this convention unless indicated otherwise.\n\nTable 2: PMX model parameter overloadings. One can use 1d array real[] to indicate constants of all events, or 2d array real[ , ] so that the \\(i\\)th row of the array describes the model arguments for time interval \\((t_{i-1}, t_i)\\), and the number of the rows equals to the size of time.     Argument Name Definition Stan data type Optional     theta model parameters real[] or real[ , ] N   biovar bioavailability fraction real[] or real[ , ] Y (default to 1.0)   tlag lag time real[] or real[ , ] Y (default to 0.0)    ","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:23-07:00","objectID":"1be780d743bcf9be42cd7956067fb49e","permalink":"https://metrumresearchgroup.github.io/Torsten/function/events/","publishdate":"2021-06-25T00:00:00-07:00","title":"Events specification"},{"content":" .ox-hugo-toc ul { list-style: none; }   Table of Contents  1 Description 2 Usage 3 Arguments 4 Return value 5 Note    1 Description Function pmx_solve_adams, pmx_solve_bdf, and pmx_solve_rk45 solve a first-order ODE system specified by user-specified right-hand-side function ODE_rhs \\(f\\)\n\\begin{equation*} y\u0026#39;(t) = f(t, y(t)) \\end{equation*}\nIn the case where the rate vector \\(r\\) is non-zero, this equation becomes:\n\\begin{equation*} y\u0026#39;(t) = f(t, y(t)) + r \\end{equation*}\n2 Usage matrix pmx_solve_[adams || rk45 || bdf](ODE_rhs, int nCmt, time, amt, rate, ii, evid, cmt, addl, ss, theta, [ biovar, tlag, real[,] x_r, int [,] x_i, real rel_tol, real abs_tol, int max_step, real as_rel_tol, real as_abs_tol, int as_max_step ] ); Here [adams || rk45 || bdf] indicates the function name can use any of the three suffixes. See below.\n3 Arguments  ODE_rhs ODE right-hand-side \\(f\\). It should be defined in functions block and has the following format   vector = f(real t, vector y, real[] param, real[] dat_r, int[] dat_i) {...} Here t is time, y the unknowns of ODE, param the parameters, dat\\_r the real data, dat\\_i the integer data. param, dat\\_r, and dat\\_i are from the entry of theta, x_r, and x_i corresponding to t, respectively. \\(f\\) should not include dosing rates in its definition, as Torsten automatically update \\(f\\) when the corresponding event indicates infusion dosage.\n nCmt The number of compartments, equivalently, the dimension of the ODE system. x_r 2d arary real data to be passed to ODE RHS. If specified, its 1st dimension should have the same size as time. x_i 2d arary integer data to be passed to ODE RHS. If specified, its 1st dimension should have the same size as time. rel_tol The relative tolerance for numerical integration, default to 1.0E-6. abs_tol The absolute tolerance for numerical integration, default to 1.0E-6. max_step The maximum number of steps in numerical integration, default to \\(10^6\\). as_rel_tol The relative tolerance for algebra solver for …","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:25-07:00","objectID":"6fa8b99b230199863ebc0b7d27fdcbc5","permalink":"https://metrumresearchgroup.github.io/Torsten/function/genode/","publishdate":"2021-06-25T00:00:00-07:00","title":"General ODE Model Function"},{"content":" .ox-hugo-toc ul { list-style: none; }   Table of Contents  1 Description 2 Usage 3 Arguments 4 Return value    1 Description Function pmx_solve_linode solves a (piecewise) linear ODEs model with coefficients in form of matrix \\(K\\)\n\\begin{equation} y^\\prime\\left(t\\right) = Ky\\left(t\\right) \\end{equation}\nFor example, in a two-compartment model with first order absorption, \\(K\\) is\n\\begin{equation} K = \\left[\\begin{array}{ccc} -k_a \u0026amp;amp; 0 \u0026amp;amp; 0 \\\\\\\nk_a \u0026amp;amp; -\\left(k_{10} + k_{12}\\right) \u0026amp;amp; k_{21} \\\\\\\n0 \u0026amp;amp; k_{12} \u0026amp;amp; -k_{21} \\end{array}\\right] \\end{equation}\nwhere \\(k_{10}=CL/V_2\\), \\(k_{12}=Q/V_2\\), and \\(k_{21}=Q/V_3\\).\n2 Usage matrix = pmx_solve_linode(time, amt, rate, ii, evid, cmt, addl, ss, K, biovar, tlag ) 3 Arguments  K System parameters. K can be either  a matrix for constant parameters in all events, or an array of matrices matrix K[nt] so that the \\(i\\)th entry of the array describes the model parameters for time interval \\((t_{i-1}, t_i)\\), and the number of the rows equals to the number of event time nt.   See Tables in Section Events specification for the rest of arguments.  4 Return value An n-by-nt matrix, where nt is the number of time steps and n is the number of rows(columns) of square matrix K.\n","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:25-07:00","objectID":"943821112d3d464cbbd8cda4ce56d4d6","permalink":"https://metrumresearchgroup.github.io/Torsten/function/linode/","publishdate":"2021-06-25T00:00:00-07:00","title":"General Linear ODE Model Function"},{"content":" .ox-hugo-toc ul { list-style: none; }   Table of Contents  1 Description 2 Usage 3 Return value 4 Note    1 Description All the preivous functions solves for a single ODE system. Torsten also provides group modeling counterparts for ODE integrators. The functions solve for a group of ODE systems that share an ODE RHS but with different parameters. They have similar signatures to single-ODE integration functions.\n2 Usage matrix pmx_integrate_ode_group_[adams || rk45 || bdf](ODE_system, real[ , ] y0, real t0, int[] len, real[] ts, real[ , ] theta, real[ , ] x_r, int[ , ] x_i, [ real rtol, real atol, int max_step ] ); Here [adams || rk45 || bdf] indicates the function name can be of any of the three suffixes. See Section ODE integrator function.\n ODE_rhs Function that specifies the right-hand-side \\(f\\). See Section ODE integrator function. y0 Initial condition \\(y_0\\) for each subsystem in the group. The first dimension equals to the size of the group. t0 Initial time \\(t_0\\). len A vector that contains the number of output time points for each subsystem. The lenght of the vector equals to the size of the group. ts Output time when solution is seeked, consisting of ts of each subsystem concatenated. theta 2d-array parameters to be passed to ODE_rhs function. Each row corresponds to one subsystem. x_r 2d-array real data to be passed to ODE_rhs function. Each row corresponds to one subsystem. x_i 2d-array integer data to be passed to ODE_rhs function. Each row corresponds to one subsystem. rtol Relative tolerance. atol Absolute tolerance. max_step Maximum number of steps allowed between neighboring time in ts.  3 Return value An n-by-nd matrix, where n is the size of ts and nd the dimension of the system.\n4 Note  With optional arguments indicated by square bracket, the following calls are allowed:   pmx_integrate_group_[adams || rk45 || bdf](..., x_i); pmx_integrate_group_[adams || rk45 || bdf](..., x_i, rel_tol, abs_tol, max_step);  The group integrators support …","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:28-07:00","objectID":"9fd9513e889d551706a185647cf90933","permalink":"https://metrumresearchgroup.github.io/Torsten/function/ode-group-integ/","publishdate":"2021-06-25T00:00:00-07:00","title":"ODE group  integrator Function"},{"content":"Description Torsten provides its own implementation of ODE solvers that solves\n\\begin{equation*} y\u0026#39;(t) = f(t, y(t)), \\quad y(t_0) = y_0 \\end{equation*}\nfor \\(y\\). These solvers are customized for Torsten applications and different from those found in Stan. The general ODE PMX solvers in previous sections are internally powered by these functions.\nUsage real[ , ] pmx_integrate_ode_[ adams || bdf || rk45 ](ODE_rhs, real[] y0, real t0, real[] ts, real[] theta, real[] x_r, int[] x_i [ , real rtol, real atol, int max_step ]); Arguments  ODE_rhs Function that specifies the right-hand-side \\(f\\). It should be defined in functions block and has the following format   vector = f(real t, vector y, real[] param, real[] dat_r, int[] dat_i) {...} Here t is time, y the unknowns of ODE, param the parameters, dat\\_r the real data, dat\\_i the integer data.\n y0 Initial condition \\(y_0\\). t0 Initial time \\(t_0\\). ts Output time when solution is seeked. theta Parameters to be passed to ODE_rhs function. x_r Real data to be passed to ODE_rhs function. x_i Integer data to be passed to ODE_rhs function. rtol Relative tolerance, default to 1.e-6(rk45) and 1.e-8(adams and bdf). atol Absolute tolerance, default to 1.e-6(rk45) and 1.e-8(adams and bdf). max_step Maximum number of steps allowed between neighboring time in ts, default to 100000.  Return value An n-by-nd 2d-array, where n is the size of ts and nd the dimension of the system.\nNote   Three numerical integrator are provided:\n pmx_integrate_ode_adams: Adams-Moulton method, pmx_integrate_ode_bdf: Backward-differentiation formular, pmx_integrate_ode_rk45: Runge-Kutta 4/5 method.  When not equipped with further understanding of the ODE system, as a rule of thumb we suggest user try rk45 integrator first, bdf integrator when the system is suspected to be stiff, and adams when a non-stiff system needs to be solved with higher accuracy/smaller tolerance.\n  All three integrators support adaptive stepping. To achieve that, at step \\(i\\) …","date":1624863600,"description":"","lastmod":"2021-06-30T11:38:27-07:00","objectID":"f1c44095cc0351d6071d857f37fbf76f","permalink":"https://metrumresearchgroup.github.io/Torsten/function/ode-integ/","publishdate":"2021-06-28T00:00:00-07:00","title":"ODE  integrator function"},{"content":" .ox-hugo-toc ul { list-style: none; }   Table of Contents  1 Description 2 Usage 3 Arguments 4 Return value 5 Note    1 Description All the preivous functions solves for a single sunject. Torsten also provides population modeling counterparts for ODE solutions. The functions solve for a population that share an ODE model but with subject-level parameters and event specifications and have similar signatures to single-subject functions, except that now events arguments time, amt, rate, ii, evid, cmt, addl, ss specifies the entire population, one subject after another.\n2 Usage matrix pmx_solve_group_[adams || rk45 || bdf](ODE_rhs, int nCmt, int[] len, time, amt, rate, ii, evid, cmt, addl, ss, theta, [ biovar, tlag, real[,] x_r, int [,] x_i, real rel_tol, real abs_tol, int max_step, real as_rel_tol, real as_abs_tol, int as_max_step ] ); Here [adams || rk45 || bdf] indicates the function name can be of any of the three suffixes. See Section ODE integrator function.\n3 Arguments  ODE_rhs Same as in Section ODE integrator function. time, amt, rate, ii, evid, cmt, addl, ss 2d-array arguments that describe data record for the entire population (see also Tables in Section Events specification). They must have same size in the first dimension. Take evid for example. Let \\(N\\) be the population size, then evid[1,] to evid[n1,] specifies events ID for subject 1, evid[n1 + 1,] to evid[n1 + n2,] for subject 2, etc. With \\(n_i\\) being the number of events for subject \\(i\\), \\(i=1, 2, \\dots, N\\), the size of evid\u0026amp;rsquo;s first dimension is \\(\\sum_{i}n_i\\). len The length of data for each subject within the above events arrays. The size of len equals to population size \\(N\\). nCmt The number of compartments. Equivalently, the dimension of the ODE system. x_r 2d arary real data to be passed to ODE RHS. If specified, its 1st dimension should have the same size as time. x_i 2d arary integer data to be passed to ODE RHS. If specified, its 1st dimension should have the same size as time. …","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:26-07:00","objectID":"51961db3c8f4dcb36775580a7f7e3f16","permalink":"https://metrumresearchgroup.github.io/Torsten/function/ode-pop/","publishdate":"2021-06-25T00:00:00-07:00","title":"General ODE-based Population Model Function"},{"content":" .ox-hugo-toc ul { list-style: none; }   Table of Contents  1 Description 2 Usage 3 Arguments 4 Return value 5 Note    1 Description Function pmx_solve_onecpt solves a one-compartment PK model (Figure 1). The model obtains the mass \\((y_1, y_2)\\) in each compartment by solving the ordinary differential equations(ODEs)\n\\begin{align}\\label{eq:onecpt} y_1\u0026#39; \u0026amp;amp;= -k_a y_1, \\\\\\\ny_2\u0026#39; \u0026amp;amp;= k_a y_1 - \\left(\\frac{CL}{V_2} + \\frac{Q}{V_2}\\right) y_2. \\end{align}\nThe plasma concentrations of parent drug in the central compartment can then be calculated as \\(c=y_2/V_2\\).\n\n Figure 1: One and two compartment models with first order absorption implemented in Torsten.\n  2 Usage matrix = pmx_solve_onecpt(time, amt, rate, ii, evid, cmt, addl, ss, theta [, biovar, tlag ] ) 3 Arguments See Tables in Section Events specification.\n4 Return value An ncmt-by-nt matrix, where nt is the number of time steps and ncmt=2 is the number of compartments.\n5 Note  ODE Parameters theta should consist of \\(CL\\), \\(V_2\\), \\(k_a\\), in that order. biovar and tlag are optional, so that the following are allowed:   pmx_solve_onecpt(..., theta); pmx_solve_onecpt(..., theta, biovar); pmx_solve_onecpt(..., theta, biovar, tlag);  Setting \\(k_a = 0\\) eliminates the first-order absorption.  ","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:24-07:00","objectID":"f78189442122e92166382ca7c409517e","permalink":"https://metrumresearchgroup.github.io/Torsten/function/one-cpt/","publishdate":"2021-06-25T00:00:00-07:00","title":"One Compartment Model"},{"content":"real linear_interpolation(real xout, real[] x, real[] y) real[] linear_interpolation(real[] xout, real[] x, real[] y) Torsten also provides function linear_interpolation for piecewise linear interpolation over a set of x, y pairs. It returns the values of a piecewise linear function at specified values xout of the first function argument. The function is specified in terms of a set of x, y pairs. Specifically, linear_interpolation implements the following function\n\\begin{align*} y_{\\text{out}} = \\left\\{\\begin{array}{ll} y_1, \u0026amp;amp; x_{\\text{out}} \u0026amp;lt; x_1 \\\\\\\ny_i + \\frac{y_{i+1} - y_i}{x_{i+1} - x_i} \\left(x_{\\text{out}} - x_i\\right), \u0026amp;amp; x_{\\text{out}} \\in [x_i, x_{i+1}) \\\\\\\ny_n, \u0026amp;amp; x_{\\text{out}} \\ge x_n \\end{array}\\right. \\end{align*}\n The x values must be in increasing order, i.e. \\(x_i \u0026amp;lt; x_{i+1}\\). All three arguments may be data or parameters.  ","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:29-07:00","objectID":"7f9825d91e2dbb8d136f72b4ab852c35","permalink":"https://metrumresearchgroup.github.io/Torsten/function/pc_lin_interp/pc_lin_interp/","publishdate":"2021-06-25T00:00:00-07:00","title":"Piecewise linear interpolation"},{"content":" .ox-hugo-toc ul { list-style: none; }   Table of Contents  1 Description 2 Usage 3 Arguments 4 Return value 5 Note    1 Description Function pmx_solve_twocpt solves a two-compartment PK model (Figure /Torsten/function/one-cpt/). The model obtains the mass \\((y_1, y_2, y_3)\\) in each compartment by solving the ODEs\n\\begin{align} \\label{eq:twocpt} y_1\u0026#39; \u0026amp;amp;= -k_a y_1 \\\\\\\ny_2\u0026#39; \u0026amp;amp;= k_a y_1 - \\left(\\frac{CL}{V_2} + \\frac{Q}{V_2}\\right) y_2 + \\frac{Q}{V_3} y_3 \\\\\\\ny_3\u0026#39; \u0026amp;amp;= \\frac{Q}{V_2} y_2 - \\frac{Q}{V_3} y_3 \\end{align}\nThe plasma concentrations of parent drug in the central compartment can then be calculated as \\(c=y_2/V_2\\).\n2 Usage matrix = pmx_solve_twocpt(time, amt, rate, ii, evid, cmt, addl, ss, theta [, biovar, tlag ] ) 3 Arguments See Tables in Section Events specification.\n4 Return value An ncmt-by-nt matrix, where nt is the number of time steps and ncmt=3 is the number of compartments.\n5 Note  ODE Parameters theta consists of \\(CL\\), \\(Q\\), \\(V_2\\), \\(V_3\\), \\(k_a\\). biovar and tlag are optional, so that the following are allowed:   pmx_solve_twocpt(..., theta); pmx_solve_twocpt(..., theta, biovar); pmx_solve_twocpt(..., theta, biovar, tlag);  Setting \\(k_a = 0\\) eliminates the first-order absorption.  ","date":1624604400,"description":"","lastmod":"2021-06-30T11:38:24-07:00","objectID":"da8dc9a58a1969903e0b1782f699e0d1","permalink":"https://metrumresearchgroup.github.io/Torsten/function/two-cpt/","publishdate":"2021-06-25T00:00:00-07:00","title":"Two Compartment Model"}]
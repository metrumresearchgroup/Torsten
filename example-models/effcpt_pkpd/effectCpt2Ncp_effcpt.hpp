
// Code generated by stanc defd4a9
#include <stan/model/model_header.hpp>
namespace effectCpt2Ncp_effcpt_model_namespace {


inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 49, column 2 to column 24)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 50, column 2 to column 23)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 51, column 2 to column 35)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 52, column 2 to column 25)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 53, column 2 to column 24)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 54, column 2 to column 26)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 55, column 2 to column 23)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 56, column 2 to column 24)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 57, column 2 to column 35)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 58, column 2 to column 34)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 59, column 2 to column 24)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 60, column 2 to column 26)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 61, column 2 to column 30)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 65, column 2 to column 38)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 66, column 2 to column 40)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 67, column 2 to column 26)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 68, column 2 to column 25)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 69, column 2 to column 26)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 70, column 2 to column 27)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 71, column 2 to column 28)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 72, column 2 to column 26)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 73, column 2 to column 29)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 74, column 2 to column 30)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 75, column 2 to column 32)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 76, column 2 to column 36)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 77, column 2 to column 39)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 78, column 2 to column 20)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 79, column 2 to column 21)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 81, column 2 to column 69)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 83, column 2 to line 84, column 48)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 87, column 4 to column 48)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 88, column 4 to column 40)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 89, column 4 to column 24)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 90, column 4 to column 25)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 91, column 4 to column 26)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 92, column 4 to column 24)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 94, column 4 to column 25)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 95, column 4 to column 24)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 96, column 4 to column 25)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 97, column 4 to column 26)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 99, column 4 to line 107, column 65)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 109, column 4 to column 58)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 110, column 4 to column 59)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 112, column 6 to column 84)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 111, column 4 to line 112, column 84)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 86, column 17 to line 113, column 3)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 86, column 2 to line 113, column 3)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 115, column 2 to column 25)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 116, column 2 to column 31)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 141, column 2 to column 30)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 142, column 2 to column 29)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 143, column 2 to column 30)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 144, column 2 to column 31)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 145, column 2 to column 32)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 146, column 2 to column 30)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 147, column 2 to column 22)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 148, column 2 to column 23)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 149, column 2 to column 25)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 150, column 2 to column 20)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 151, column 2 to column 23)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 152, column 2 to column 20)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 153, column 2 to column 23)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 154, column 2 to column 44)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 155, column 2 to column 25)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 156, column 2 to column 25)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 157, column 2 to column 27)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 158, column 2 to column 34)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 160, column 2 to column 45)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 163, column 6 to column 42)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 162, column 4 to line 163, column 42)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 161, column 2 to line 163, column 42)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 165, column 2 to line 166, column 56)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 169, column 4 to column 56)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 170, column 4 to column 48)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 171, column 4 to column 32)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 172, column 4 to column 33)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 173, column 4 to column 34)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 174, column 4 to column 32)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 176, column 4 to column 34)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 177, column 4 to column 34)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 178, column 4 to column 33)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 179, column 4 to column 35)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 181, column 4 to line 189, column 74)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 191, column 4 to column 70)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 192, column 4 to column 71)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 194, column 6 to line 195, column 63)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 193, column 4 to line 195, column 63)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 168, column 17 to line 196, column 3)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 168, column 2 to line 196, column 3)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 203, column 6 to line 204, column 16)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 205, column 6 to line 206, column 31)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 202, column 9 to line 207, column 5)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 200, column 6 to column 22)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 201, column 6 to column 22)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 199, column 20 to line 202, column 5)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 199, column 4 to line 207, column 5)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 208, column 4 to line 209, column 30)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 210, column 4 to line 211, column 34)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 198, column 16 to line 212, column 3)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 198, column 2 to line 212, column 3)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 120, column 2 to column 45)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 121, column 2 to column 42)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 122, column 2 to column 45)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 123, column 2 to column 23)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 124, column 2 to column 48)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 125, column 2 to column 45)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 126, column 2 to column 51)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 127, column 2 to column 48)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 128, column 2 to column 51)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 129, column 2 to column 25)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 130, column 2 to column 23)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 131, column 2 to column 27)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 134, column 2 to column 35)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 136, column 2 to column 40)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 137, column 2 to column 48)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 2, column 2 to column 21)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 3, column 2 to column 20)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 4, column 2 to column 24)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 5, column 2 to column 24)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 6, column 24 to column 30)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 6, column 2 to column 32)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 7, column 24 to column 30)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 7, column 2 to column 32)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 8, column 22 to column 24)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 8, column 2 to column 26)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 9, column 21 to column 23)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 9, column 2 to column 25)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 10, column 22 to column 24)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 10, column 2 to column 26)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 11, column 21 to column 23)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 11, column 2 to column 25)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 12, column 22 to column 24)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 12, column 2 to column 26)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 13, column 23 to column 25)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 13, column 2 to column 27)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 14, column 20 to column 22)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 14, column 2 to column 24)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 15, column 23 to column 26)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 15, column 2 to column 28)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 16, column 21 to column 24)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 16, column 2 to column 26)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 17, column 25 to column 28)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 17, column 2 to column 30)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 18, column 23 to column 25)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 18, column 2 to column 27)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 19, column 20 to column 26)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 19, column 2 to column 33)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 20, column 20 to column 26)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 20, column 2 to column 36)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 21, column 2 to column 26)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 22, column 2 to column 25)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 23, column 2 to column 26)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 24, column 2 to column 28)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 25, column 2 to column 27)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 26, column 2 to column 28)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 27, column 2 to column 27)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 28, column 2 to column 29)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 29, column 2 to column 26)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 30, column 2 to column 28)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 31, column 2 to column 28)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 32, column 2 to column 30)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 33, column 2 to column 28)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 34, column 2 to column 30)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 35, column 2 to column 29)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 36, column 2 to column 31)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 40, column 9 to column 15)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 40, column 2 to column 37)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 41, column 9 to column 15)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 41, column 2 to column 43)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 42, column 2 to column 29)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 43, column 2 to column 26)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 44, column 9 to column 13)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 44, column 2 to column 38)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 45, column 12 to column 16)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 45, column 2 to column 41)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 57, column 20 to column 27)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 58, column 23 to column 30)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 61, column 9 to column 16)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 61, column 18 to column 21)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 65, column 20 to column 27)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 66, column 20 to column 23)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 66, column 25 to column 32)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 67, column 21 to column 24)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 68, column 20 to column 23)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 69, column 21 to column 24)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 70, column 22 to column 25)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 71, column 23 to column 26)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 72, column 21 to column 24)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 73, column 20 to column 22)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 74, column 20 to column 22)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 75, column 20 to column 22)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 76, column 20 to column 26)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 77, column 20 to column 26)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 79, column 9 to column 13)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 79, column 15 to column 17)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 141, column 25 to column 28)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 142, column 24 to column 27)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 143, column 25 to column 28)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 144, column 26 to column 29)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 145, column 27 to column 30)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 146, column 25 to column 28)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 147, column 9 to column 11)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 148, column 9 to column 11)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 149, column 9 to column 11)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 150, column 16 to column 18)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 151, column 19 to column 21)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 152, column 16 to column 18)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 153, column 19 to column 21)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 154, column 20 to column 23)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 154, column 25 to column 32)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 155, column 9 to column 13)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 155, column 15 to column 17)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 157, column 14 to column 21)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 158, column 9 to column 16)",
                                                      " (in '../Torsten/example-models/effcpt_pkpd/effectCpt2Ncp_effcpt.stan', line 158, column 18 to column 21)"};



class effectCpt2Ncp_effcpt_model final : public model_base_crtp<effectCpt2Ncp_effcpt_model> {

 private:
  int nId;
  int nt;
  int nObsPK;
  int nObsPD;
  std::vector<int> iObsPK;
  std::vector<int> iObsPD;
  std::vector<double> amt;
  std::vector<int> cmt;
  std::vector<int> evid;
  std::vector<double> ii;
  std::vector<int> addl;
  std::vector<double> rate;
  std::vector<int> ss;
  std::vector<int> start;
  std::vector<int> end;
  std::vector<double> weight;
  std::vector<double> time;
  Eigen::Matrix<double, -1, 1> cObs;
  Eigen::Matrix<double, -1, 1> respObs;
  double CLPrior;
  double VPrior;
  double kaPrior;
  double CLPriorCV;
  double VPriorCV;
  double kaPriorCV;
  double ke0Prior;
  double ke0PriorCV;
  double E0Prior;
  double E0PriorCV;
  double EmaxPrior;
  double EmaxPriorCV;
  double EC50Prior;
  double EC50PriorCV;
  double gammaPrior;
  double gammaPriorCV;
  Eigen::Matrix<double, -1, 1> logCObs;
  Eigen::Matrix<double, -1, 1> logRespObs;
  int nRandom;
  int nCmt;
  std::vector<double> F;
  std::vector<double> tLag;
 
 public:
  ~effectCpt2Ncp_effcpt_model() final { }
  
  std::string model_name() const final { return "effectCpt2Ncp_effcpt_model"; }

  std::vector<std::string> model_compile_info() const {
    std::vector<std::string> stanc_info;
    stanc_info.push_back("stanc_version = stanc3 defd4a9");
    stanc_info.push_back("stancflags = ");
    return stanc_info;
  }
  
  
  effectCpt2Ncp_effcpt_model(stan::io::var_context& context__,
                             unsigned int random_seed__ = 0,
                             std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "effectCpt2Ncp_effcpt_model_namespace::effectCpt2Ncp_effcpt_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 116;
      context__.validate_dims("data initialization","nId","int",
          context__.to_vec());
      nId = std::numeric_limits<int>::min();
      
      current_statement__ = 116;
      nId = context__.vals_i("nId")[(1 - 1)];
      current_statement__ = 116;
      current_statement__ = 116;
      check_greater_or_equal(function__, "nId", nId, 1);
      current_statement__ = 117;
      context__.validate_dims("data initialization","nt","int",
          context__.to_vec());
      nt = std::numeric_limits<int>::min();
      
      current_statement__ = 117;
      nt = context__.vals_i("nt")[(1 - 1)];
      current_statement__ = 117;
      current_statement__ = 117;
      check_greater_or_equal(function__, "nt", nt, 1);
      current_statement__ = 118;
      context__.validate_dims("data initialization","nObsPK","int",
          context__.to_vec());
      nObsPK = std::numeric_limits<int>::min();
      
      current_statement__ = 118;
      nObsPK = context__.vals_i("nObsPK")[(1 - 1)];
      current_statement__ = 118;
      current_statement__ = 118;
      check_greater_or_equal(function__, "nObsPK", nObsPK, 1);
      current_statement__ = 119;
      context__.validate_dims("data initialization","nObsPD","int",
          context__.to_vec());
      nObsPD = std::numeric_limits<int>::min();
      
      current_statement__ = 119;
      nObsPD = context__.vals_i("nObsPD")[(1 - 1)];
      current_statement__ = 119;
      current_statement__ = 119;
      check_greater_or_equal(function__, "nObsPD", nObsPD, 1);
      current_statement__ = 120;
      validate_non_negative_index("iObsPK", "nObsPK", nObsPK);
      current_statement__ = 121;
      context__.validate_dims("data initialization","iObsPK","int",
          context__.to_vec(nObsPK));
      iObsPK = std::vector<int>(nObsPK, std::numeric_limits<int>::min());
      
      current_statement__ = 121;
      assign(iObsPK, nil_index_list(), context__.vals_i("iObsPK"),
        "assigning variable iObsPK");
      current_statement__ = 121;
      for (int sym1__ = 1; sym1__ <= nObsPK; ++sym1__) {
        current_statement__ = 121;
        current_statement__ = 121;
        check_greater_or_equal(function__, "iObsPK[sym1__]",
                               iObsPK[(sym1__ - 1)], 1);}
      current_statement__ = 122;
      validate_non_negative_index("iObsPD", "nObsPD", nObsPD);
      current_statement__ = 123;
      context__.validate_dims("data initialization","iObsPD","int",
          context__.to_vec(nObsPD));
      iObsPD = std::vector<int>(nObsPD, std::numeric_limits<int>::min());
      
      current_statement__ = 123;
      assign(iObsPD, nil_index_list(), context__.vals_i("iObsPD"),
        "assigning variable iObsPD");
      current_statement__ = 123;
      for (int sym1__ = 1; sym1__ <= nObsPD; ++sym1__) {
        current_statement__ = 123;
        current_statement__ = 123;
        check_greater_or_equal(function__, "iObsPD[sym1__]",
                               iObsPD[(sym1__ - 1)], 1);}
      current_statement__ = 124;
      validate_non_negative_index("amt", "nt", nt);
      current_statement__ = 125;
      context__.validate_dims("data initialization","amt","double",
          context__.to_vec(nt));
      amt = std::vector<double>(nt, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 125;
      assign(amt, nil_index_list(), context__.vals_r("amt"),
        "assigning variable amt");
      current_statement__ = 125;
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        current_statement__ = 125;
        current_statement__ = 125;
        check_greater_or_equal(function__, "amt[sym1__]", amt[(sym1__ - 1)],
                               0);}
      current_statement__ = 126;
      validate_non_negative_index("cmt", "nt", nt);
      current_statement__ = 127;
      context__.validate_dims("data initialization","cmt","int",
          context__.to_vec(nt));
      cmt = std::vector<int>(nt, std::numeric_limits<int>::min());
      
      current_statement__ = 127;
      assign(cmt, nil_index_list(), context__.vals_i("cmt"),
        "assigning variable cmt");
      current_statement__ = 127;
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        current_statement__ = 127;
        current_statement__ = 127;
        check_greater_or_equal(function__, "cmt[sym1__]", cmt[(sym1__ - 1)],
                               1);}
      current_statement__ = 128;
      validate_non_negative_index("evid", "nt", nt);
      current_statement__ = 129;
      context__.validate_dims("data initialization","evid","int",
          context__.to_vec(nt));
      evid = std::vector<int>(nt, std::numeric_limits<int>::min());
      
      current_statement__ = 129;
      assign(evid, nil_index_list(), context__.vals_i("evid"),
        "assigning variable evid");
      current_statement__ = 129;
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        current_statement__ = 129;
        current_statement__ = 129;
        check_greater_or_equal(function__, "evid[sym1__]",
                               evid[(sym1__ - 1)], 0);}
      current_statement__ = 130;
      validate_non_negative_index("ii", "nt", nt);
      current_statement__ = 131;
      context__.validate_dims("data initialization","ii","double",
          context__.to_vec(nt));
      ii = std::vector<double>(nt, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 131;
      assign(ii, nil_index_list(), context__.vals_r("ii"),
        "assigning variable ii");
      current_statement__ = 131;
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        current_statement__ = 131;
        current_statement__ = 131;
        check_greater_or_equal(function__, "ii[sym1__]", ii[(sym1__ - 1)], 0);
      }
      current_statement__ = 132;
      validate_non_negative_index("addl", "nt", nt);
      current_statement__ = 133;
      context__.validate_dims("data initialization","addl","int",
          context__.to_vec(nt));
      addl = std::vector<int>(nt, std::numeric_limits<int>::min());
      
      current_statement__ = 133;
      assign(addl, nil_index_list(), context__.vals_i("addl"),
        "assigning variable addl");
      current_statement__ = 133;
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        current_statement__ = 133;
        current_statement__ = 133;
        check_greater_or_equal(function__, "addl[sym1__]",
                               addl[(sym1__ - 1)], 0);}
      current_statement__ = 134;
      validate_non_negative_index("rate", "nt", nt);
      current_statement__ = 135;
      context__.validate_dims("data initialization","rate","double",
          context__.to_vec(nt));
      rate = std::vector<double>(nt, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 135;
      assign(rate, nil_index_list(), context__.vals_r("rate"),
        "assigning variable rate");
      current_statement__ = 135;
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        current_statement__ = 135;
        current_statement__ = 135;
        check_greater_or_equal(function__, "rate[sym1__]",
                               rate[(sym1__ - 1)], 0);}
      current_statement__ = 136;
      validate_non_negative_index("ss", "nt", nt);
      current_statement__ = 137;
      context__.validate_dims("data initialization","ss","int",
          context__.to_vec(nt));
      ss = std::vector<int>(nt, std::numeric_limits<int>::min());
      
      current_statement__ = 137;
      assign(ss, nil_index_list(), context__.vals_i("ss"),
        "assigning variable ss");
      current_statement__ = 137;
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        current_statement__ = 137;
        current_statement__ = 137;
        check_greater_or_equal(function__, "ss[sym1__]", ss[(sym1__ - 1)], 0);
      }
      current_statement__ = 138;
      validate_non_negative_index("start", "nId", nId);
      current_statement__ = 139;
      context__.validate_dims("data initialization","start","int",
          context__.to_vec(nId));
      start = std::vector<int>(nId, std::numeric_limits<int>::min());
      
      current_statement__ = 139;
      assign(start, nil_index_list(), context__.vals_i("start"),
        "assigning variable start");
      current_statement__ = 139;
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        current_statement__ = 139;
        current_statement__ = 139;
        check_greater_or_equal(function__, "start[sym1__]",
                               start[(sym1__ - 1)], 1);}
      current_statement__ = 140;
      validate_non_negative_index("end", "nId", nId);
      current_statement__ = 141;
      context__.validate_dims("data initialization","end","int",
          context__.to_vec(nId));
      end = std::vector<int>(nId, std::numeric_limits<int>::min());
      
      current_statement__ = 141;
      assign(end, nil_index_list(), context__.vals_i("end"),
        "assigning variable end");
      current_statement__ = 141;
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        current_statement__ = 141;
        current_statement__ = 141;
        check_greater_or_equal(function__, "end[sym1__]", end[(sym1__ - 1)],
                               1);}
      current_statement__ = 142;
      validate_non_negative_index("weight", "nId", nId);
      current_statement__ = 143;
      context__.validate_dims("data initialization","weight","double",
          context__.to_vec(nId));
      weight = std::vector<double>(nId, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 143;
      assign(weight, nil_index_list(), context__.vals_r("weight"),
        "assigning variable weight");
      current_statement__ = 143;
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        current_statement__ = 143;
        current_statement__ = 143;
        check_greater_or_equal(function__, "weight[sym1__]",
                               weight[(sym1__ - 1)], 0);}
      current_statement__ = 144;
      validate_non_negative_index("time", "nt", nt);
      current_statement__ = 145;
      context__.validate_dims("data initialization","time","double",
          context__.to_vec(nt));
      time = std::vector<double>(nt, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 145;
      assign(time, nil_index_list(), context__.vals_r("time"),
        "assigning variable time");
      current_statement__ = 145;
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        current_statement__ = 145;
        current_statement__ = 145;
        check_greater_or_equal(function__, "time[sym1__]",
                               time[(sym1__ - 1)], 0);}
      current_statement__ = 146;
      validate_non_negative_index("cObs", "nObsPK", nObsPK);
      current_statement__ = 147;
      context__.validate_dims("data initialization","cObs","double",
          context__.to_vec(nObsPK));
      cObs = Eigen::Matrix<double, -1, 1>(nObsPK);
      stan::math::fill(cObs, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> cObs_flat__;
        current_statement__ = 147;
        assign(cObs_flat__, nil_index_list(), context__.vals_r("cObs"),
          "assigning variable cObs_flat__");
        current_statement__ = 147;
        pos__ = 1;
        current_statement__ = 147;
        for (int sym1__ = 1; sym1__ <= nObsPK; ++sym1__) {
          current_statement__ = 147;
          assign(cObs, cons_list(index_uni(sym1__), nil_index_list()),
            cObs_flat__[(pos__ - 1)], "assigning variable cObs");
          current_statement__ = 147;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 147;
      for (int sym1__ = 1; sym1__ <= nObsPK; ++sym1__) {
        current_statement__ = 147;
        current_statement__ = 147;
        check_greater_or_equal(function__, "cObs[sym1__]",
                               cObs[(sym1__ - 1)], 0);}
      current_statement__ = 148;
      validate_non_negative_index("respObs", "nObsPD", nObsPD);
      current_statement__ = 149;
      context__.validate_dims("data initialization","respObs","double",
          context__.to_vec(nObsPD));
      respObs = Eigen::Matrix<double, -1, 1>(nObsPD);
      stan::math::fill(respObs, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> respObs_flat__;
        current_statement__ = 149;
        assign(respObs_flat__, nil_index_list(), context__.vals_r("respObs"),
          "assigning variable respObs_flat__");
        current_statement__ = 149;
        pos__ = 1;
        current_statement__ = 149;
        for (int sym1__ = 1; sym1__ <= nObsPD; ++sym1__) {
          current_statement__ = 149;
          assign(respObs, cons_list(index_uni(sym1__), nil_index_list()),
            respObs_flat__[(pos__ - 1)], "assigning variable respObs");
          current_statement__ = 149;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 149;
      for (int sym1__ = 1; sym1__ <= nObsPD; ++sym1__) {
        current_statement__ = 149;
        current_statement__ = 149;
        check_greater_or_equal(function__, "respObs[sym1__]",
                               respObs[(sym1__ - 1)], 0);}
      current_statement__ = 150;
      context__.validate_dims("data initialization","CLPrior","double",
          context__.to_vec());
      CLPrior = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 150;
      CLPrior = context__.vals_r("CLPrior")[(1 - 1)];
      current_statement__ = 150;
      current_statement__ = 150;
      check_greater_or_equal(function__, "CLPrior", CLPrior, 0);
      current_statement__ = 151;
      context__.validate_dims("data initialization","VPrior","double",
          context__.to_vec());
      VPrior = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 151;
      VPrior = context__.vals_r("VPrior")[(1 - 1)];
      current_statement__ = 151;
      current_statement__ = 151;
      check_greater_or_equal(function__, "VPrior", VPrior, 0);
      current_statement__ = 152;
      context__.validate_dims("data initialization","kaPrior","double",
          context__.to_vec());
      kaPrior = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 152;
      kaPrior = context__.vals_r("kaPrior")[(1 - 1)];
      current_statement__ = 152;
      current_statement__ = 152;
      check_greater_or_equal(function__, "kaPrior", kaPrior, 0);
      current_statement__ = 153;
      context__.validate_dims("data initialization","CLPriorCV","double",
          context__.to_vec());
      CLPriorCV = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 153;
      CLPriorCV = context__.vals_r("CLPriorCV")[(1 - 1)];
      current_statement__ = 153;
      current_statement__ = 153;
      check_greater_or_equal(function__, "CLPriorCV", CLPriorCV, 0);
      current_statement__ = 154;
      context__.validate_dims("data initialization","VPriorCV","double",
          context__.to_vec());
      VPriorCV = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 154;
      VPriorCV = context__.vals_r("VPriorCV")[(1 - 1)];
      current_statement__ = 154;
      current_statement__ = 154;
      check_greater_or_equal(function__, "VPriorCV", VPriorCV, 0);
      current_statement__ = 155;
      context__.validate_dims("data initialization","kaPriorCV","double",
          context__.to_vec());
      kaPriorCV = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 155;
      kaPriorCV = context__.vals_r("kaPriorCV")[(1 - 1)];
      current_statement__ = 155;
      current_statement__ = 155;
      check_greater_or_equal(function__, "kaPriorCV", kaPriorCV, 0);
      current_statement__ = 156;
      context__.validate_dims("data initialization","ke0Prior","double",
          context__.to_vec());
      ke0Prior = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 156;
      ke0Prior = context__.vals_r("ke0Prior")[(1 - 1)];
      current_statement__ = 156;
      current_statement__ = 156;
      check_greater_or_equal(function__, "ke0Prior", ke0Prior, 0);
      current_statement__ = 157;
      context__.validate_dims("data initialization","ke0PriorCV","double",
          context__.to_vec());
      ke0PriorCV = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 157;
      ke0PriorCV = context__.vals_r("ke0PriorCV")[(1 - 1)];
      current_statement__ = 157;
      current_statement__ = 157;
      check_greater_or_equal(function__, "ke0PriorCV", ke0PriorCV, 0);
      current_statement__ = 158;
      context__.validate_dims("data initialization","E0Prior","double",
          context__.to_vec());
      E0Prior = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 158;
      E0Prior = context__.vals_r("E0Prior")[(1 - 1)];
      current_statement__ = 158;
      current_statement__ = 158;
      check_greater_or_equal(function__, "E0Prior", E0Prior, 0);
      current_statement__ = 159;
      context__.validate_dims("data initialization","E0PriorCV","double",
          context__.to_vec());
      E0PriorCV = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 159;
      E0PriorCV = context__.vals_r("E0PriorCV")[(1 - 1)];
      current_statement__ = 159;
      current_statement__ = 159;
      check_greater_or_equal(function__, "E0PriorCV", E0PriorCV, 0);
      current_statement__ = 160;
      context__.validate_dims("data initialization","EmaxPrior","double",
          context__.to_vec());
      EmaxPrior = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 160;
      EmaxPrior = context__.vals_r("EmaxPrior")[(1 - 1)];
      current_statement__ = 160;
      current_statement__ = 160;
      check_greater_or_equal(function__, "EmaxPrior", EmaxPrior, 0);
      current_statement__ = 161;
      context__.validate_dims("data initialization","EmaxPriorCV","double",
          context__.to_vec());
      EmaxPriorCV = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 161;
      EmaxPriorCV = context__.vals_r("EmaxPriorCV")[(1 - 1)];
      current_statement__ = 161;
      current_statement__ = 161;
      check_greater_or_equal(function__, "EmaxPriorCV", EmaxPriorCV, 0);
      current_statement__ = 162;
      context__.validate_dims("data initialization","EC50Prior","double",
          context__.to_vec());
      EC50Prior = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 162;
      EC50Prior = context__.vals_r("EC50Prior")[(1 - 1)];
      current_statement__ = 162;
      current_statement__ = 162;
      check_greater_or_equal(function__, "EC50Prior", EC50Prior, 0);
      current_statement__ = 163;
      context__.validate_dims("data initialization","EC50PriorCV","double",
          context__.to_vec());
      EC50PriorCV = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 163;
      EC50PriorCV = context__.vals_r("EC50PriorCV")[(1 - 1)];
      current_statement__ = 163;
      current_statement__ = 163;
      check_greater_or_equal(function__, "EC50PriorCV", EC50PriorCV, 0);
      current_statement__ = 164;
      context__.validate_dims("data initialization","gammaPrior","double",
          context__.to_vec());
      gammaPrior = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 164;
      gammaPrior = context__.vals_r("gammaPrior")[(1 - 1)];
      current_statement__ = 164;
      current_statement__ = 164;
      check_greater_or_equal(function__, "gammaPrior", gammaPrior, 0);
      current_statement__ = 165;
      context__.validate_dims("data initialization","gammaPriorCV","double",
          context__.to_vec());
      gammaPriorCV = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 165;
      gammaPriorCV = context__.vals_r("gammaPriorCV")[(1 - 1)];
      current_statement__ = 165;
      current_statement__ = 165;
      check_greater_or_equal(function__, "gammaPriorCV", gammaPriorCV, 0);
      current_statement__ = 166;
      validate_non_negative_index("logCObs", "nObsPK", nObsPK);
      current_statement__ = 167;
      logCObs = Eigen::Matrix<double, -1, 1>(nObsPK);
      stan::math::fill(logCObs, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 167;
      assign(logCObs, nil_index_list(), stan::math::log(cObs),
        "assigning variable logCObs");
      current_statement__ = 168;
      validate_non_negative_index("logRespObs", "nObsPD", nObsPD);
      current_statement__ = 169;
      logRespObs = Eigen::Matrix<double, -1, 1>(nObsPD);
      stan::math::fill(logRespObs, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 169;
      assign(logRespObs, nil_index_list(), stan::math::log(respObs),
        "assigning variable logRespObs");
      current_statement__ = 170;
      nRandom = std::numeric_limits<int>::min();
      
      current_statement__ = 170;
      nRandom = 6;
      current_statement__ = 171;
      nCmt = std::numeric_limits<int>::min();
      
      current_statement__ = 171;
      nCmt = 3;
      current_statement__ = 172;
      validate_non_negative_index("F", "nCmt", nCmt);
      current_statement__ = 173;
      F = std::vector<double>(nCmt, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 173;
      assign(F, nil_index_list(), rep_array(1.0, nCmt),
        "assigning variable F");
      current_statement__ = 174;
      validate_non_negative_index("tLag", "nCmt", nCmt);
      current_statement__ = 175;
      tLag = std::vector<double>(nCmt, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 175;
      assign(tLag, nil_index_list(), rep_array(0.0, nCmt),
        "assigning variable tLag");
      current_statement__ = 170;
      current_statement__ = 170;
      check_greater_or_equal(function__, "nRandom", nRandom, 1);
      current_statement__ = 171;
      current_statement__ = 171;
      check_greater_or_equal(function__, "nCmt", nCmt, 1);
      current_statement__ = 176;
      validate_non_negative_index("omega", "nRandom", nRandom);
      current_statement__ = 177;
      validate_non_negative_index("L", "nRandom", nRandom);
      current_statement__ = 177;
      validate_non_negative_index("L", "nRandom", nRandom);
      current_statement__ = 178;
      validate_non_negative_index("etaStd", "nRandom", nRandom);
      current_statement__ = 179;
      validate_non_negative_index("etaStd", "nId", nId);
      current_statement__ = 180;
      validate_non_negative_index("thetaHat", "nRandom", nRandom);
      current_statement__ = 181;
      validate_non_negative_index("theta", "nId", nId);
      current_statement__ = 182;
      validate_non_negative_index("theta", "nRandom", nRandom);
      current_statement__ = 183;
      validate_non_negative_index("CL", "nId", nId);
      current_statement__ = 184;
      validate_non_negative_index("V", "nId", nId);
      current_statement__ = 185;
      validate_non_negative_index("ka", "nId", nId);
      current_statement__ = 186;
      validate_non_negative_index("ke0", "nId", nId);
      current_statement__ = 187;
      validate_non_negative_index("Emax", "nId", nId);
      current_statement__ = 188;
      validate_non_negative_index("E0", "nId", nId);
      current_statement__ = 189;
      validate_non_negative_index("cHat", "nt", nt);
      current_statement__ = 190;
      validate_non_negative_index("ceHat", "nt", nt);
      current_statement__ = 191;
      validate_non_negative_index("respHat", "nt", nt);
      current_statement__ = 192;
      validate_non_negative_index("cHatObs", "nObsPK", nObsPK);
      current_statement__ = 193;
      validate_non_negative_index("respHatObs", "nObsPD", nObsPD);
      current_statement__ = 194;
      validate_non_negative_index("x", "nCmt", nCmt);
      current_statement__ = 195;
      validate_non_negative_index("x", "nt", nt);
      current_statement__ = 196;
      validate_non_negative_index("CLPred", "nId", nId);
      current_statement__ = 197;
      validate_non_negative_index("VPred", "nId", nId);
      current_statement__ = 198;
      validate_non_negative_index("kaPred", "nId", nId);
      current_statement__ = 199;
      validate_non_negative_index("ke0Pred", "nId", nId);
      current_statement__ = 200;
      validate_non_negative_index("EmaxPred", "nId", nId);
      current_statement__ = 201;
      validate_non_negative_index("E0Pred", "nId", nId);
      current_statement__ = 202;
      validate_non_negative_index("cHatPred", "nt", nt);
      current_statement__ = 203;
      validate_non_negative_index("ceHatPred", "nt", nt);
      current_statement__ = 204;
      validate_non_negative_index("respHatPred", "nt", nt);
      current_statement__ = 205;
      validate_non_negative_index("cObsCond", "nt", nt);
      current_statement__ = 206;
      validate_non_negative_index("respObsCond", "nt", nt);
      current_statement__ = 207;
      validate_non_negative_index("cObsPred", "nt", nt);
      current_statement__ = 208;
      validate_non_negative_index("respObsPred", "nt", nt);
      current_statement__ = 209;
      validate_non_negative_index("thetaPred", "nId", nId);
      current_statement__ = 210;
      validate_non_negative_index("thetaPred", "nRandom", nRandom);
      current_statement__ = 211;
      validate_non_negative_index("xPred", "nCmt", nCmt);
      current_statement__ = 212;
      validate_non_negative_index("xPred", "nt", nt);
      current_statement__ = 213;
      validate_non_negative_index("rho", "nRandom", nRandom);
      current_statement__ = 213;
      validate_non_negative_index("rho", "nRandom", nRandom);
      current_statement__ = 214;
      validate_non_negative_index("etaStdPred", "nRandom", nRandom);
      current_statement__ = 215;
      validate_non_negative_index("etaStdPred", "nId", nId);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += nRandom;
      num_params_r__ += ((nRandom * (nRandom - 1)) / 2);
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += nRandom * nId;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  inline T__ log_prob(std::vector<T__>& params_r__,
                      std::vector<int>& params_i__,
                      std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "effectCpt2Ncp_effcpt_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      local_scalar_t__ CLHat;
      CLHat = DUMMY_VAR__;
      
      current_statement__ = 1;
      CLHat = in__.scalar();
      current_statement__ = 1;
      if (jacobian__) {
        current_statement__ = 1;
        CLHat = stan::math::lb_constrain(CLHat, 0, lp__);
      } else {
        current_statement__ = 1;
        CLHat = stan::math::lb_constrain(CLHat, 0);
      }
      local_scalar_t__ VHat;
      VHat = DUMMY_VAR__;
      
      current_statement__ = 2;
      VHat = in__.scalar();
      current_statement__ = 2;
      if (jacobian__) {
        current_statement__ = 2;
        VHat = stan::math::lb_constrain(VHat, 0, lp__);
      } else {
        current_statement__ = 2;
        VHat = stan::math::lb_constrain(VHat, 0);
      }
      local_scalar_t__ kaHat;
      kaHat = DUMMY_VAR__;
      
      current_statement__ = 3;
      kaHat = in__.scalar();
      current_statement__ = 3;
      if (jacobian__) {
        current_statement__ = 3;
        kaHat = stan::math::lb_constrain(kaHat, (CLHat / VHat), lp__);
      } else {
        current_statement__ = 3;
        kaHat = stan::math::lb_constrain(kaHat, (CLHat / VHat));
      }
      local_scalar_t__ ke0Hat;
      ke0Hat = DUMMY_VAR__;
      
      current_statement__ = 4;
      ke0Hat = in__.scalar();
      current_statement__ = 4;
      if (jacobian__) {
        current_statement__ = 4;
        ke0Hat = stan::math::lb_constrain(ke0Hat, 0, lp__);
      } else {
        current_statement__ = 4;
        ke0Hat = stan::math::lb_constrain(ke0Hat, 0);
      }
      local_scalar_t__ E0Hat;
      E0Hat = DUMMY_VAR__;
      
      current_statement__ = 5;
      E0Hat = in__.scalar();
      current_statement__ = 5;
      if (jacobian__) {
        current_statement__ = 5;
        E0Hat = stan::math::lb_constrain(E0Hat, 0, lp__);
      } else {
        current_statement__ = 5;
        E0Hat = stan::math::lb_constrain(E0Hat, 0);
      }
      local_scalar_t__ EmaxHat;
      EmaxHat = DUMMY_VAR__;
      
      current_statement__ = 6;
      EmaxHat = in__.scalar();
      current_statement__ = 6;
      if (jacobian__) {
        current_statement__ = 6;
        EmaxHat = stan::math::lb_constrain(EmaxHat, 0, lp__);
      } else {
        current_statement__ = 6;
        EmaxHat = stan::math::lb_constrain(EmaxHat, 0);
      }
      local_scalar_t__ EC50;
      EC50 = DUMMY_VAR__;
      
      current_statement__ = 7;
      EC50 = in__.scalar();
      current_statement__ = 7;
      if (jacobian__) {
        current_statement__ = 7;
        EC50 = stan::math::lb_constrain(EC50, 0, lp__);
      } else {
        current_statement__ = 7;
        EC50 = stan::math::lb_constrain(EC50, 0);
      }
      local_scalar_t__ gamma;
      gamma = DUMMY_VAR__;
      
      current_statement__ = 8;
      gamma = in__.scalar();
      current_statement__ = 8;
      if (jacobian__) {
        current_statement__ = 8;
        gamma = stan::math::lb_constrain(gamma, 0, lp__);
      } else {
        current_statement__ = 8;
        gamma = stan::math::lb_constrain(gamma, 0);
      }
      Eigen::Matrix<local_scalar_t__, -1, 1> omega;
      omega = Eigen::Matrix<local_scalar_t__, -1, 1>(nRandom);
      stan::math::fill(omega, DUMMY_VAR__);
      
      current_statement__ = 9;
      omega = in__.vector(nRandom);
      current_statement__ = 9;
      for (int sym1__ = 1; sym1__ <= nRandom; ++sym1__) {
        current_statement__ = 9;
        if (jacobian__) {
          current_statement__ = 9;
          assign(omega, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(omega[(sym1__ - 1)], 0, lp__),
            "assigning variable omega");
        } else {
          current_statement__ = 9;
          assign(omega, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(omega[(sym1__ - 1)], 0),
            "assigning variable omega");
        }}
      Eigen::Matrix<local_scalar_t__, -1, -1> L;
      L = Eigen::Matrix<local_scalar_t__, -1, -1>(nRandom, nRandom);
      stan::math::fill(L, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> L_in__;
      L_in__ = Eigen::Matrix<local_scalar_t__, -1, 1>(((nRandom *
                                                         (nRandom - 1)) / 2));
      stan::math::fill(L_in__, DUMMY_VAR__);
      
      current_statement__ = 10;
      L_in__ = in__.vector(((nRandom * (nRandom - 1)) / 2));
      current_statement__ = 10;
      if (jacobian__) {
        current_statement__ = 10;
        assign(L, nil_index_list(),
          stan::math::cholesky_corr_constrain(L_in__, nRandom, lp__),
          "assigning variable L");
      } else {
        current_statement__ = 10;
        assign(L, nil_index_list(),
          stan::math::cholesky_corr_constrain(L_in__, nRandom),
          "assigning variable L");
      }
      local_scalar_t__ sigma;
      sigma = DUMMY_VAR__;
      
      current_statement__ = 11;
      sigma = in__.scalar();
      current_statement__ = 11;
      if (jacobian__) {
        current_statement__ = 11;
        sigma = stan::math::lb_constrain(sigma, 0, lp__);
      } else {
        current_statement__ = 11;
        sigma = stan::math::lb_constrain(sigma, 0);
      }
      local_scalar_t__ sigmaPD;
      sigmaPD = DUMMY_VAR__;
      
      current_statement__ = 12;
      sigmaPD = in__.scalar();
      current_statement__ = 12;
      if (jacobian__) {
        current_statement__ = 12;
        sigmaPD = stan::math::lb_constrain(sigmaPD, 0, lp__);
      } else {
        current_statement__ = 12;
        sigmaPD = stan::math::lb_constrain(sigmaPD, 0);
      }
      Eigen::Matrix<local_scalar_t__, -1, -1> etaStd;
      etaStd = Eigen::Matrix<local_scalar_t__, -1, -1>(nRandom, nId);
      stan::math::fill(etaStd, DUMMY_VAR__);
      
      current_statement__ = 13;
      etaStd = in__.matrix(nRandom, nId);
      Eigen::Matrix<local_scalar_t__, -1, 1> thetaHat;
      thetaHat = Eigen::Matrix<local_scalar_t__, -1, 1>(nRandom);
      stan::math::fill(thetaHat, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> theta;
      theta = Eigen::Matrix<local_scalar_t__, -1, -1>(nId, nRandom);
      stan::math::fill(theta, DUMMY_VAR__);
      
      std::vector<local_scalar_t__> CL;
      CL = std::vector<local_scalar_t__>(nId, DUMMY_VAR__);
      
      std::vector<local_scalar_t__> V;
      V = std::vector<local_scalar_t__>(nId, DUMMY_VAR__);
      
      std::vector<local_scalar_t__> ka;
      ka = std::vector<local_scalar_t__>(nId, DUMMY_VAR__);
      
      std::vector<local_scalar_t__> ke0;
      ke0 = std::vector<local_scalar_t__>(nId, DUMMY_VAR__);
      
      std::vector<local_scalar_t__> Emax;
      Emax = std::vector<local_scalar_t__>(nId, DUMMY_VAR__);
      
      std::vector<local_scalar_t__> E0;
      E0 = std::vector<local_scalar_t__>(nId, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> cHat;
      cHat = Eigen::Matrix<local_scalar_t__, -1, 1>(nt);
      stan::math::fill(cHat, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> ceHat;
      ceHat = Eigen::Matrix<local_scalar_t__, -1, 1>(nt);
      stan::math::fill(ceHat, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> respHat;
      respHat = Eigen::Matrix<local_scalar_t__, -1, 1>(nt);
      stan::math::fill(respHat, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> cHatObs;
      cHatObs = Eigen::Matrix<local_scalar_t__, -1, 1>(nObsPK);
      stan::math::fill(cHatObs, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> respHatObs;
      respHatObs = Eigen::Matrix<local_scalar_t__, -1, 1>(nObsPD);
      stan::math::fill(respHatObs, DUMMY_VAR__);
      
      std::vector<local_scalar_t__> model_par;
      model_par = std::vector<local_scalar_t__>(4, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> x;
      x = Eigen::Matrix<local_scalar_t__, -1, -1>(nCmt, nt);
      stan::math::fill(x, DUMMY_VAR__);
      
      current_statement__ = 29;
      assign(thetaHat, nil_index_list(),
        to_vector(stan::math::array_builder<local_scalar_t__>().add(CLHat)
          .add(VHat).add(kaHat).add(ke0Hat).add(EmaxHat).add(E0Hat).array()),
        "assigning variable thetaHat");
      current_statement__ = 30;
      assign(theta, nil_index_list(),
        transpose(
          elt_multiply(rep_matrix(thetaHat, nId),
            stan::math::exp(diag_pre_multiply(omega, multiply(L, etaStd))))),
        "assigning variable theta");
      current_statement__ = 47;
      for (int j = 1; j <= nId; ++j) {
        current_statement__ = 31;
        assign(CL, cons_list(index_uni(j), nil_index_list()),
          (rvalue(theta,
             cons_list(index_uni(j),
               cons_list(index_uni(1), nil_index_list())), "theta") *
            pow((weight[(j - 1)] / 70), 0.75)), "assigning variable CL");
        current_statement__ = 32;
        assign(V, cons_list(index_uni(j), nil_index_list()),
          ((rvalue(theta,
              cons_list(index_uni(j),
                cons_list(index_uni(2), nil_index_list())), "theta") *
             weight[(j - 1)]) / 70), "assigning variable V");
        current_statement__ = 33;
        assign(ka, cons_list(index_uni(j), nil_index_list()),
          rvalue(theta,
            cons_list(index_uni(j),
              cons_list(index_uni(3), nil_index_list())), "theta"),
          "assigning variable ka");
        current_statement__ = 34;
        assign(ke0, cons_list(index_uni(j), nil_index_list()),
          rvalue(theta,
            cons_list(index_uni(j),
              cons_list(index_uni(4), nil_index_list())), "theta"),
          "assigning variable ke0");
        current_statement__ = 35;
        assign(Emax, cons_list(index_uni(j), nil_index_list()),
          rvalue(theta,
            cons_list(index_uni(j),
              cons_list(index_uni(5), nil_index_list())), "theta"),
          "assigning variable Emax");
        current_statement__ = 36;
        assign(E0, cons_list(index_uni(j), nil_index_list()),
          rvalue(theta,
            cons_list(index_uni(j),
              cons_list(index_uni(6), nil_index_list())), "theta"),
          "assigning variable E0");
        current_statement__ = 37;
        assign(model_par, cons_list(index_uni(1), nil_index_list()),
          CL[(j - 1)], "assigning variable model_par");
        current_statement__ = 38;
        assign(model_par, cons_list(index_uni(2), nil_index_list()),
          V[(j - 1)], "assigning variable model_par");
        current_statement__ = 39;
        assign(model_par, cons_list(index_uni(3), nil_index_list()),
          ka[(j - 1)], "assigning variable model_par");
        current_statement__ = 40;
        assign(model_par, cons_list(index_uni(4), nil_index_list()),
          ke0[(j - 1)], "assigning variable model_par");
        current_statement__ = 41;
        assign(x,
          cons_list(index_omni(),
            cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
              nil_index_list())),
          pmx_solve_onecpt_effcpt(
            rvalue(time,
              cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                nil_index_list()), "time"),
            rvalue(amt,
              cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                nil_index_list()), "amt"),
            rvalue(rate,
              cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                nil_index_list()), "rate"),
            rvalue(ii,
              cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                nil_index_list()), "ii"),
            rvalue(evid,
              cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                nil_index_list()), "evid"),
            rvalue(cmt,
              cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                nil_index_list()), "cmt"),
            rvalue(addl,
              cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                nil_index_list()), "addl"),
            rvalue(ss,
              cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                nil_index_list()), "ss"), model_par, F, tLag),
          "assigning variable x");
        current_statement__ = 42;
        assign(cHat,
          cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
            nil_index_list()),
          divide(
            transpose(
              rvalue(x,
                cons_list(index_uni(2),
                  cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                    nil_index_list())), "x")), V[(j - 1)]),
          "assigning variable cHat");
        current_statement__ = 43;
        assign(ceHat,
          cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
            nil_index_list()),
          divide(
            transpose(
              rvalue(x,
                cons_list(index_uni(3),
                  cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                    nil_index_list())), "x")), V[(j - 1)]),
          "assigning variable ceHat");
        current_statement__ = 45;
        for (int i = start[(j - 1)]; i <= end[(j - 1)]; ++i) {
          current_statement__ = 44;
          assign(respHat, cons_list(index_uni(i), nil_index_list()),
            (E0[(j - 1)] +
              ((Emax[(j - 1)] * pow(ceHat[(i - 1)], gamma)) /
                (pow(EC50, gamma) + pow(ceHat[(i - 1)], gamma)))),
            "assigning variable respHat");}}
      current_statement__ = 48;
      assign(cHatObs, nil_index_list(),
        rvalue(cHat, cons_list(index_multi(iObsPK), nil_index_list()),
          "cHat"), "assigning variable cHatObs");
      current_statement__ = 49;
      assign(respHatObs, nil_index_list(),
        rvalue(respHat, cons_list(index_multi(iObsPD), nil_index_list()),
          "respHat"), "assigning variable respHatObs");
      current_statement__ = 14;
      for (int sym1__ = 1; sym1__ <= nRandom; ++sym1__) {
        current_statement__ = 14;
        current_statement__ = 14;
        check_greater_or_equal(function__, "thetaHat[sym1__]",
                               thetaHat[(sym1__ - 1)], 0);}
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        current_statement__ = 15;
        for (int sym2__ = 1; sym2__ <= nRandom; ++sym2__) {
          current_statement__ = 15;
          current_statement__ = 15;
          check_greater_or_equal(function__, "theta[sym1__, sym2__]",
                                 rvalue(theta,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "theta"), 0);}}
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        current_statement__ = 16;
        current_statement__ = 16;
        check_greater_or_equal(function__, "CL[sym1__]", CL[(sym1__ - 1)], 0);
      }
      current_statement__ = 17;
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        current_statement__ = 17;
        current_statement__ = 17;
        check_greater_or_equal(function__, "V[sym1__]", V[(sym1__ - 1)], 0);}
      current_statement__ = 18;
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        current_statement__ = 18;
        current_statement__ = 18;
        check_greater_or_equal(function__, "ka[sym1__]", ka[(sym1__ - 1)], 0);
      }
      current_statement__ = 19;
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        current_statement__ = 19;
        current_statement__ = 19;
        check_greater_or_equal(function__, "ke0[sym1__]", ke0[(sym1__ - 1)],
                               0);}
      current_statement__ = 20;
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        current_statement__ = 20;
        current_statement__ = 20;
        check_greater_or_equal(function__, "Emax[sym1__]",
                               Emax[(sym1__ - 1)], 0);}
      current_statement__ = 21;
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        current_statement__ = 21;
        current_statement__ = 21;
        check_greater_or_equal(function__, "E0[sym1__]", E0[(sym1__ - 1)], 0);
      }
      current_statement__ = 22;
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        current_statement__ = 22;
        current_statement__ = 22;
        check_greater_or_equal(function__, "cHat[sym1__]",
                               cHat[(sym1__ - 1)], 0);}
      current_statement__ = 23;
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        current_statement__ = 23;
        current_statement__ = 23;
        check_greater_or_equal(function__, "ceHat[sym1__]",
                               ceHat[(sym1__ - 1)], 0);}
      current_statement__ = 24;
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        current_statement__ = 24;
        current_statement__ = 24;
        check_greater_or_equal(function__, "respHat[sym1__]",
                               respHat[(sym1__ - 1)], 0);}
      current_statement__ = 25;
      for (int sym1__ = 1; sym1__ <= nObsPK; ++sym1__) {
        current_statement__ = 25;
        current_statement__ = 25;
        check_greater_or_equal(function__, "cHatObs[sym1__]",
                               cHatObs[(sym1__ - 1)], 0);}
      current_statement__ = 26;
      for (int sym1__ = 1; sym1__ <= nObsPD; ++sym1__) {
        current_statement__ = 26;
        current_statement__ = 26;
        check_greater_or_equal(function__, "respHatObs[sym1__]",
                               respHatObs[(sym1__ - 1)], 0);}
      {
        current_statement__ = 101;
        lp_accum__.add(
          lognormal_lpdf<propto__>(CLHat, stan::math::log(CLPrior),
            CLPriorCV));
        current_statement__ = 102;
        lp_accum__.add(
          lognormal_lpdf<propto__>(VHat, stan::math::log(VPrior), VPriorCV));
        current_statement__ = 103;
        lp_accum__.add(
          lognormal_lpdf<propto__>(kaHat, stan::math::log(kaPrior),
            kaPriorCV));
        current_statement__ = 104;
        lp_accum__.add(cauchy_lpdf<propto__>(sigma, 0, 1));
        current_statement__ = 105;
        lp_accum__.add(
          lognormal_lpdf<propto__>(ke0Hat, stan::math::log(ke0Prior),
            ke0PriorCV));
        current_statement__ = 106;
        lp_accum__.add(
          lognormal_lpdf<propto__>(E0Hat, stan::math::log(E0Prior),
            E0PriorCV));
        current_statement__ = 107;
        lp_accum__.add(
          lognormal_lpdf<propto__>(EmaxHat, stan::math::log(EmaxPrior),
            EmaxPriorCV));
        current_statement__ = 108;
        lp_accum__.add(
          lognormal_lpdf<propto__>(EC50, stan::math::log(EC50Prior),
            EC50PriorCV));
        current_statement__ = 109;
        lp_accum__.add(
          lognormal_lpdf<propto__>(gamma, stan::math::log(gammaPrior),
            gammaPriorCV));
        current_statement__ = 110;
        lp_accum__.add(cauchy_lpdf<propto__>(sigmaPD, 0, 1));
        current_statement__ = 111;
        lp_accum__.add(cauchy_lpdf<propto__>(omega, 0, 1));
        current_statement__ = 112;
        lp_accum__.add(lkj_corr_cholesky_lpdf<propto__>(L, 1));
        current_statement__ = 113;
        lp_accum__.add(normal_lpdf<propto__>(to_vector(etaStd), 0, 1));
        current_statement__ = 114;
        lp_accum__.add(
          normal_lpdf<propto__>(logCObs, stan::math::log(cHatObs), sigma));
        current_statement__ = 115;
        lp_accum__.add(
          normal_lpdf<propto__>(logRespObs, stan::math::log(respHatObs),
            sigmaPD));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  inline void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                          std::vector<int>& params_i__,
                          std::vector<double>& vars__,
                          bool emit_transformed_parameters__ = true,
                          bool emit_generated_quantities__ = true,
                          std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "effectCpt2Ncp_effcpt_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning

    
    try {
      double CLHat;
      CLHat = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      CLHat = in__.scalar();
      current_statement__ = 1;
      CLHat = stan::math::lb_constrain(CLHat, 0);
      double VHat;
      VHat = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      VHat = in__.scalar();
      current_statement__ = 2;
      VHat = stan::math::lb_constrain(VHat, 0);
      double kaHat;
      kaHat = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      kaHat = in__.scalar();
      current_statement__ = 3;
      kaHat = stan::math::lb_constrain(kaHat, (CLHat / VHat));
      double ke0Hat;
      ke0Hat = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      ke0Hat = in__.scalar();
      current_statement__ = 4;
      ke0Hat = stan::math::lb_constrain(ke0Hat, 0);
      double E0Hat;
      E0Hat = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 5;
      E0Hat = in__.scalar();
      current_statement__ = 5;
      E0Hat = stan::math::lb_constrain(E0Hat, 0);
      double EmaxHat;
      EmaxHat = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 6;
      EmaxHat = in__.scalar();
      current_statement__ = 6;
      EmaxHat = stan::math::lb_constrain(EmaxHat, 0);
      double EC50;
      EC50 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 7;
      EC50 = in__.scalar();
      current_statement__ = 7;
      EC50 = stan::math::lb_constrain(EC50, 0);
      double gamma;
      gamma = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 8;
      gamma = in__.scalar();
      current_statement__ = 8;
      gamma = stan::math::lb_constrain(gamma, 0);
      Eigen::Matrix<double, -1, 1> omega;
      omega = Eigen::Matrix<double, -1, 1>(nRandom);
      stan::math::fill(omega, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 9;
      omega = in__.vector(nRandom);
      current_statement__ = 9;
      for (int sym1__ = 1; sym1__ <= nRandom; ++sym1__) {
        current_statement__ = 9;
        assign(omega, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(omega[(sym1__ - 1)], 0),
          "assigning variable omega");}
      Eigen::Matrix<double, -1, -1> L;
      L = Eigen::Matrix<double, -1, -1>(nRandom, nRandom);
      stan::math::fill(L, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<local_scalar_t__, -1, 1> L_in__;
      L_in__ = Eigen::Matrix<local_scalar_t__, -1, 1>(((nRandom *
                                                         (nRandom - 1)) / 2));
      stan::math::fill(L_in__, DUMMY_VAR__);
      
      current_statement__ = 10;
      L_in__ = in__.vector(((nRandom * (nRandom - 1)) / 2));
      current_statement__ = 10;
      assign(L, nil_index_list(),
        stan::math::cholesky_corr_constrain(L_in__, nRandom),
        "assigning variable L");
      double sigma;
      sigma = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 11;
      sigma = in__.scalar();
      current_statement__ = 11;
      sigma = stan::math::lb_constrain(sigma, 0);
      double sigmaPD;
      sigmaPD = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 12;
      sigmaPD = in__.scalar();
      current_statement__ = 12;
      sigmaPD = stan::math::lb_constrain(sigmaPD, 0);
      Eigen::Matrix<double, -1, -1> etaStd;
      etaStd = Eigen::Matrix<double, -1, -1>(nRandom, nId);
      stan::math::fill(etaStd, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 13;
      etaStd = in__.matrix(nRandom, nId);
      Eigen::Matrix<double, -1, 1> thetaHat;
      thetaHat = Eigen::Matrix<double, -1, 1>(nRandom);
      stan::math::fill(thetaHat, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> theta;
      theta = Eigen::Matrix<double, -1, -1>(nId, nRandom);
      stan::math::fill(theta, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<double> CL;
      CL = std::vector<double>(nId, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<double> V;
      V = std::vector<double>(nId, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<double> ka;
      ka = std::vector<double>(nId, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<double> ke0;
      ke0 = std::vector<double>(nId, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<double> Emax;
      Emax = std::vector<double>(nId, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<double> E0;
      E0 = std::vector<double>(nId, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> cHat;
      cHat = Eigen::Matrix<double, -1, 1>(nt);
      stan::math::fill(cHat, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> ceHat;
      ceHat = Eigen::Matrix<double, -1, 1>(nt);
      stan::math::fill(ceHat, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> respHat;
      respHat = Eigen::Matrix<double, -1, 1>(nt);
      stan::math::fill(respHat, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> cHatObs;
      cHatObs = Eigen::Matrix<double, -1, 1>(nObsPK);
      stan::math::fill(cHatObs, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> respHatObs;
      respHatObs = Eigen::Matrix<double, -1, 1>(nObsPD);
      stan::math::fill(respHatObs, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<double> model_par;
      model_par = std::vector<double>(4, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> x;
      x = Eigen::Matrix<double, -1, -1>(nCmt, nt);
      stan::math::fill(x, std::numeric_limits<double>::quiet_NaN());
      
      vars__.emplace_back(CLHat);
      vars__.emplace_back(VHat);
      vars__.emplace_back(kaHat);
      vars__.emplace_back(ke0Hat);
      vars__.emplace_back(E0Hat);
      vars__.emplace_back(EmaxHat);
      vars__.emplace_back(EC50);
      vars__.emplace_back(gamma);
      for (int sym1__ = 1; sym1__ <= nRandom; ++sym1__) {
        vars__.emplace_back(omega[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nRandom; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= nRandom; ++sym2__) {
          vars__.emplace_back(
            rvalue(L,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())), "L"));}}
      vars__.emplace_back(sigma);
      vars__.emplace_back(sigmaPD);
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= nRandom; ++sym2__) {
          vars__.emplace_back(
            rvalue(etaStd,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())), "etaStd"));}
      }
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 29;
      assign(thetaHat, nil_index_list(),
        to_vector(stan::math::array_builder<local_scalar_t__>().add(CLHat)
          .add(VHat).add(kaHat).add(ke0Hat).add(EmaxHat).add(E0Hat).array()),
        "assigning variable thetaHat");
      current_statement__ = 30;
      assign(theta, nil_index_list(),
        transpose(
          elt_multiply(rep_matrix(thetaHat, nId),
            stan::math::exp(diag_pre_multiply(omega, multiply(L, etaStd))))),
        "assigning variable theta");
      current_statement__ = 47;
      for (int j = 1; j <= nId; ++j) {
        current_statement__ = 31;
        assign(CL, cons_list(index_uni(j), nil_index_list()),
          (rvalue(theta,
             cons_list(index_uni(j),
               cons_list(index_uni(1), nil_index_list())), "theta") *
            pow((weight[(j - 1)] / 70), 0.75)), "assigning variable CL");
        current_statement__ = 32;
        assign(V, cons_list(index_uni(j), nil_index_list()),
          ((rvalue(theta,
              cons_list(index_uni(j),
                cons_list(index_uni(2), nil_index_list())), "theta") *
             weight[(j - 1)]) / 70), "assigning variable V");
        current_statement__ = 33;
        assign(ka, cons_list(index_uni(j), nil_index_list()),
          rvalue(theta,
            cons_list(index_uni(j),
              cons_list(index_uni(3), nil_index_list())), "theta"),
          "assigning variable ka");
        current_statement__ = 34;
        assign(ke0, cons_list(index_uni(j), nil_index_list()),
          rvalue(theta,
            cons_list(index_uni(j),
              cons_list(index_uni(4), nil_index_list())), "theta"),
          "assigning variable ke0");
        current_statement__ = 35;
        assign(Emax, cons_list(index_uni(j), nil_index_list()),
          rvalue(theta,
            cons_list(index_uni(j),
              cons_list(index_uni(5), nil_index_list())), "theta"),
          "assigning variable Emax");
        current_statement__ = 36;
        assign(E0, cons_list(index_uni(j), nil_index_list()),
          rvalue(theta,
            cons_list(index_uni(j),
              cons_list(index_uni(6), nil_index_list())), "theta"),
          "assigning variable E0");
        current_statement__ = 37;
        assign(model_par, cons_list(index_uni(1), nil_index_list()),
          CL[(j - 1)], "assigning variable model_par");
        current_statement__ = 38;
        assign(model_par, cons_list(index_uni(2), nil_index_list()),
          V[(j - 1)], "assigning variable model_par");
        current_statement__ = 39;
        assign(model_par, cons_list(index_uni(3), nil_index_list()),
          ka[(j - 1)], "assigning variable model_par");
        current_statement__ = 40;
        assign(model_par, cons_list(index_uni(4), nil_index_list()),
          ke0[(j - 1)], "assigning variable model_par");
        current_statement__ = 41;
        assign(x,
          cons_list(index_omni(),
            cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
              nil_index_list())),
          pmx_solve_onecpt_effcpt(
            rvalue(time,
              cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                nil_index_list()), "time"),
            rvalue(amt,
              cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                nil_index_list()), "amt"),
            rvalue(rate,
              cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                nil_index_list()), "rate"),
            rvalue(ii,
              cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                nil_index_list()), "ii"),
            rvalue(evid,
              cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                nil_index_list()), "evid"),
            rvalue(cmt,
              cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                nil_index_list()), "cmt"),
            rvalue(addl,
              cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                nil_index_list()), "addl"),
            rvalue(ss,
              cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                nil_index_list()), "ss"), model_par, F, tLag),
          "assigning variable x");
        current_statement__ = 42;
        assign(cHat,
          cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
            nil_index_list()),
          divide(
            transpose(
              rvalue(x,
                cons_list(index_uni(2),
                  cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                    nil_index_list())), "x")), V[(j - 1)]),
          "assigning variable cHat");
        current_statement__ = 43;
        assign(ceHat,
          cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
            nil_index_list()),
          divide(
            transpose(
              rvalue(x,
                cons_list(index_uni(3),
                  cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                    nil_index_list())), "x")), V[(j - 1)]),
          "assigning variable ceHat");
        current_statement__ = 45;
        for (int i = start[(j - 1)]; i <= end[(j - 1)]; ++i) {
          current_statement__ = 44;
          assign(respHat, cons_list(index_uni(i), nil_index_list()),
            (E0[(j - 1)] +
              ((Emax[(j - 1)] * pow(ceHat[(i - 1)], gamma)) /
                (pow(EC50, gamma) + pow(ceHat[(i - 1)], gamma)))),
            "assigning variable respHat");}}
      current_statement__ = 48;
      assign(cHatObs, nil_index_list(),
        rvalue(cHat, cons_list(index_multi(iObsPK), nil_index_list()),
          "cHat"), "assigning variable cHatObs");
      current_statement__ = 49;
      assign(respHatObs, nil_index_list(),
        rvalue(respHat, cons_list(index_multi(iObsPD), nil_index_list()),
          "respHat"), "assigning variable respHatObs");
      current_statement__ = 14;
      for (int sym1__ = 1; sym1__ <= nRandom; ++sym1__) {
        current_statement__ = 14;
        current_statement__ = 14;
        check_greater_or_equal(function__, "thetaHat[sym1__]",
                               thetaHat[(sym1__ - 1)], 0);}
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        current_statement__ = 15;
        for (int sym2__ = 1; sym2__ <= nRandom; ++sym2__) {
          current_statement__ = 15;
          current_statement__ = 15;
          check_greater_or_equal(function__, "theta[sym1__, sym2__]",
                                 rvalue(theta,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "theta"), 0);}}
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        current_statement__ = 16;
        current_statement__ = 16;
        check_greater_or_equal(function__, "CL[sym1__]", CL[(sym1__ - 1)], 0);
      }
      current_statement__ = 17;
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        current_statement__ = 17;
        current_statement__ = 17;
        check_greater_or_equal(function__, "V[sym1__]", V[(sym1__ - 1)], 0);}
      current_statement__ = 18;
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        current_statement__ = 18;
        current_statement__ = 18;
        check_greater_or_equal(function__, "ka[sym1__]", ka[(sym1__ - 1)], 0);
      }
      current_statement__ = 19;
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        current_statement__ = 19;
        current_statement__ = 19;
        check_greater_or_equal(function__, "ke0[sym1__]", ke0[(sym1__ - 1)],
                               0);}
      current_statement__ = 20;
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        current_statement__ = 20;
        current_statement__ = 20;
        check_greater_or_equal(function__, "Emax[sym1__]",
                               Emax[(sym1__ - 1)], 0);}
      current_statement__ = 21;
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        current_statement__ = 21;
        current_statement__ = 21;
        check_greater_or_equal(function__, "E0[sym1__]", E0[(sym1__ - 1)], 0);
      }
      current_statement__ = 22;
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        current_statement__ = 22;
        current_statement__ = 22;
        check_greater_or_equal(function__, "cHat[sym1__]",
                               cHat[(sym1__ - 1)], 0);}
      current_statement__ = 23;
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        current_statement__ = 23;
        current_statement__ = 23;
        check_greater_or_equal(function__, "ceHat[sym1__]",
                               ceHat[(sym1__ - 1)], 0);}
      current_statement__ = 24;
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        current_statement__ = 24;
        current_statement__ = 24;
        check_greater_or_equal(function__, "respHat[sym1__]",
                               respHat[(sym1__ - 1)], 0);}
      current_statement__ = 25;
      for (int sym1__ = 1; sym1__ <= nObsPK; ++sym1__) {
        current_statement__ = 25;
        current_statement__ = 25;
        check_greater_or_equal(function__, "cHatObs[sym1__]",
                               cHatObs[(sym1__ - 1)], 0);}
      current_statement__ = 26;
      for (int sym1__ = 1; sym1__ <= nObsPD; ++sym1__) {
        current_statement__ = 26;
        current_statement__ = 26;
        check_greater_or_equal(function__, "respHatObs[sym1__]",
                               respHatObs[(sym1__ - 1)], 0);}
      if (emit_transformed_parameters__) {
        for (int sym1__ = 1; sym1__ <= nRandom; ++sym1__) {
          vars__.emplace_back(thetaHat[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= nRandom; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nId; ++sym2__) {
            vars__.emplace_back(
              rvalue(theta,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "theta"));
          }}
        for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
          vars__.emplace_back(CL[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
          vars__.emplace_back(V[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
          vars__.emplace_back(ka[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
          vars__.emplace_back(ke0[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
          vars__.emplace_back(Emax[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
          vars__.emplace_back(E0[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
          vars__.emplace_back(cHat[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
          vars__.emplace_back(ceHat[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
          vars__.emplace_back(respHat[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= nObsPK; ++sym1__) {
          vars__.emplace_back(cHatObs[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= nObsPD; ++sym1__) {
          vars__.emplace_back(respHatObs[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
          vars__.emplace_back(model_par[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nCmt; ++sym2__) {
            vars__.emplace_back(
              rvalue(x,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "x"));}}
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      std::vector<double> CLPred;
      CLPred = std::vector<double>(nId, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<double> VPred;
      VPred = std::vector<double>(nId, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<double> kaPred;
      kaPred = std::vector<double>(nId, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<double> ke0Pred;
      ke0Pred = std::vector<double>(nId, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<double> EmaxPred;
      EmaxPred = std::vector<double>(nId, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<double> E0Pred;
      E0Pred = std::vector<double>(nId, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> cHatPred;
      cHatPred = Eigen::Matrix<double, -1, 1>(nt);
      stan::math::fill(cHatPred, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> ceHatPred;
      ceHatPred = Eigen::Matrix<double, -1, 1>(nt);
      stan::math::fill(ceHatPred, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> respHatPred;
      respHatPred = Eigen::Matrix<double, -1, 1>(nt);
      stan::math::fill(respHatPred, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<double> cObsCond;
      cObsCond = std::vector<double>(nt, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<double> respObsCond;
      respObsCond = std::vector<double>(nt, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<double> cObsPred;
      cObsPred = std::vector<double>(nt, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<double> respObsPred;
      respObsPred = std::vector<double>(nt, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> thetaPred;
      thetaPred = Eigen::Matrix<double, -1, -1>(nId, nRandom);
      stan::math::fill(thetaPred, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> xPred;
      xPred = Eigen::Matrix<double, -1, -1>(nCmt, nt);
      stan::math::fill(xPred, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<double> model_par_pred;
      model_par_pred = std::vector<double>(4, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> rho;
      rho = Eigen::Matrix<double, -1, -1>(nRandom, nRandom);
      stan::math::fill(rho, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> etaStdPred;
      etaStdPred = Eigen::Matrix<double, -1, -1>(nRandom, nId);
      stan::math::fill(etaStdPred, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 68;
      assign(rho, nil_index_list(), multiply_lower_tri_self_transpose(L),
        "assigning variable rho");
      current_statement__ = 71;
      for (int j = 1; j <= nId; ++j) {
        current_statement__ = 70;
        for (int i = 1; i <= nRandom; ++i) {
          current_statement__ = 69;
          assign(etaStdPred,
            cons_list(index_uni(i),
              cons_list(index_uni(j), nil_index_list())),
            normal_rng(0, 1, base_rng__), "assigning variable etaStdPred");}}
      current_statement__ = 72;
      assign(thetaPred, nil_index_list(),
        transpose(
          elt_multiply(rep_matrix(thetaHat, nId),
            stan::math::exp(
              diag_pre_multiply(omega, multiply(L, etaStdPred))))),
        "assigning variable thetaPred");
      current_statement__ = 89;
      for (int j = 1; j <= nId; ++j) {
        current_statement__ = 73;
        assign(CLPred, cons_list(index_uni(j), nil_index_list()),
          (rvalue(thetaPred,
             cons_list(index_uni(j),
               cons_list(index_uni(1), nil_index_list())), "thetaPred") *
            pow((weight[(j - 1)] / 70), 0.75)), "assigning variable CLPred");
        current_statement__ = 74;
        assign(VPred, cons_list(index_uni(j), nil_index_list()),
          ((rvalue(thetaPred,
              cons_list(index_uni(j),
                cons_list(index_uni(2), nil_index_list())), "thetaPred") *
             weight[(j - 1)]) / 70), "assigning variable VPred");
        current_statement__ = 75;
        assign(kaPred, cons_list(index_uni(j), nil_index_list()),
          rvalue(thetaPred,
            cons_list(index_uni(j),
              cons_list(index_uni(3), nil_index_list())), "thetaPred"),
          "assigning variable kaPred");
        current_statement__ = 76;
        assign(ke0Pred, cons_list(index_uni(j), nil_index_list()),
          rvalue(thetaPred,
            cons_list(index_uni(j),
              cons_list(index_uni(4), nil_index_list())), "thetaPred"),
          "assigning variable ke0Pred");
        current_statement__ = 77;
        assign(EmaxPred, cons_list(index_uni(j), nil_index_list()),
          rvalue(thetaPred,
            cons_list(index_uni(j),
              cons_list(index_uni(5), nil_index_list())), "thetaPred"),
          "assigning variable EmaxPred");
        current_statement__ = 78;
        assign(E0Pred, cons_list(index_uni(j), nil_index_list()),
          rvalue(thetaPred,
            cons_list(index_uni(j),
              cons_list(index_uni(6), nil_index_list())), "thetaPred"),
          "assigning variable E0Pred");
        current_statement__ = 79;
        assign(model_par_pred, cons_list(index_uni(1), nil_index_list()),
          kaPred[(j - 1)], "assigning variable model_par_pred");
        current_statement__ = 80;
        assign(model_par_pred, cons_list(index_uni(2), nil_index_list()),
          CLPred[(j - 1)], "assigning variable model_par_pred");
        current_statement__ = 81;
        assign(model_par_pred, cons_list(index_uni(3), nil_index_list()),
          VPred[(j - 1)], "assigning variable model_par_pred");
        current_statement__ = 82;
        assign(model_par_pred, cons_list(index_uni(4), nil_index_list()),
          ke0Pred[(j - 1)], "assigning variable model_par_pred");
        current_statement__ = 83;
        assign(xPred,
          cons_list(index_omni(),
            cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
              nil_index_list())),
          pmx_solve_onecpt_effcpt(
            rvalue(time,
              cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                nil_index_list()), "time"),
            rvalue(amt,
              cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                nil_index_list()), "amt"),
            rvalue(rate,
              cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                nil_index_list()), "rate"),
            rvalue(ii,
              cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                nil_index_list()), "ii"),
            rvalue(evid,
              cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                nil_index_list()), "evid"),
            rvalue(cmt,
              cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                nil_index_list()), "cmt"),
            rvalue(addl,
              cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                nil_index_list()), "addl"),
            rvalue(ss,
              cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                nil_index_list()), "ss"), model_par_pred, F, tLag),
          "assigning variable xPred");
        current_statement__ = 84;
        assign(cHatPred,
          cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
            nil_index_list()),
          divide(
            transpose(
              rvalue(xPred,
                cons_list(index_uni(2),
                  cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                    nil_index_list())), "xPred")), VPred[(j - 1)]),
          "assigning variable cHatPred");
        current_statement__ = 85;
        assign(ceHatPred,
          cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
            nil_index_list()),
          divide(
            transpose(
              rvalue(xPred,
                cons_list(index_uni(3),
                  cons_list(index_min_max(start[(j - 1)], end[(j - 1)]),
                    nil_index_list())), "xPred")), VPred[(j - 1)]),
          "assigning variable ceHatPred");
        current_statement__ = 87;
        for (int i = start[(j - 1)]; i <= end[(j - 1)]; ++i) {
          current_statement__ = 86;
          assign(respHatPred, cons_list(index_uni(i), nil_index_list()),
            (E0Pred[(j - 1)] +
              ((EmaxPred[(j - 1)] * pow(ceHatPred[(i - 1)], gamma)) /
                (pow(EC50, gamma) + pow(ceHatPred[(i - 1)], gamma)))),
            "assigning variable respHatPred");}}
      current_statement__ = 100;
      for (int i = 1; i <= nt; ++i) {
        current_statement__ = 96;
        if (logical_eq(time[(i - 1)], 0)) {
          current_statement__ = 93;
          assign(cObsCond, cons_list(index_uni(i), nil_index_list()), 0,
            "assigning variable cObsCond");
          current_statement__ = 94;
          assign(cObsPred, cons_list(index_uni(i), nil_index_list()), 0,
            "assigning variable cObsPred");
        } else {
          current_statement__ = 90;
          assign(cObsCond, cons_list(index_uni(i), nil_index_list()),
            stan::math::exp(
              normal_rng(
                stan::math::log(
                  stan::math::fmax(stan::math::machine_precision(),
                    cHat[(i - 1)])), sigma, base_rng__)),
            "assigning variable cObsCond");
          current_statement__ = 91;
          assign(cObsPred, cons_list(index_uni(i), nil_index_list()),
            stan::math::exp(
              normal_rng(
                stan::math::log(
                  stan::math::fmax(stan::math::machine_precision(),
                    cHatPred[(i - 1)])), sigma, base_rng__)),
            "assigning variable cObsPred");
        }
        current_statement__ = 97;
        assign(respObsCond, cons_list(index_uni(i), nil_index_list()),
          stan::math::exp(
            normal_rng(
              stan::math::log(
                stan::math::fmax(stan::math::machine_precision(),
                  respHat[(i - 1)])), sigmaPD, base_rng__)),
          "assigning variable respObsCond");
        current_statement__ = 98;
        assign(respObsPred, cons_list(index_uni(i), nil_index_list()),
          stan::math::exp(
            normal_rng(
              stan::math::log(
                stan::math::fmax(stan::math::machine_precision(),
                  respHatPred[(i - 1)])), sigmaPD, base_rng__)),
          "assigning variable respObsPred");}
      current_statement__ = 50;
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        current_statement__ = 50;
        current_statement__ = 50;
        check_greater_or_equal(function__, "CLPred[sym1__]",
                               CLPred[(sym1__ - 1)], 0);}
      current_statement__ = 51;
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        current_statement__ = 51;
        current_statement__ = 51;
        check_greater_or_equal(function__, "VPred[sym1__]",
                               VPred[(sym1__ - 1)], 0);}
      current_statement__ = 52;
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        current_statement__ = 52;
        current_statement__ = 52;
        check_greater_or_equal(function__, "kaPred[sym1__]",
                               kaPred[(sym1__ - 1)], 0);}
      current_statement__ = 53;
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        current_statement__ = 53;
        current_statement__ = 53;
        check_greater_or_equal(function__, "ke0Pred[sym1__]",
                               ke0Pred[(sym1__ - 1)], 0);}
      current_statement__ = 54;
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        current_statement__ = 54;
        current_statement__ = 54;
        check_greater_or_equal(function__, "EmaxPred[sym1__]",
                               EmaxPred[(sym1__ - 1)], 0);}
      current_statement__ = 55;
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        current_statement__ = 55;
        current_statement__ = 55;
        check_greater_or_equal(function__, "E0Pred[sym1__]",
                               E0Pred[(sym1__ - 1)], 0);}
      current_statement__ = 63;
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        current_statement__ = 63;
        for (int sym2__ = 1; sym2__ <= nRandom; ++sym2__) {
          current_statement__ = 63;
          current_statement__ = 63;
          check_greater_or_equal(function__, "thetaPred[sym1__, sym2__]",
                                 rvalue(thetaPred,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "thetaPred"), 0);}
      }
      current_statement__ = 66;
      current_statement__ = 66;
      check_corr_matrix(function__, "rho", rho);
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        vars__.emplace_back(CLPred[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        vars__.emplace_back(VPred[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        vars__.emplace_back(kaPred[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        vars__.emplace_back(ke0Pred[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        vars__.emplace_back(EmaxPred[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        vars__.emplace_back(E0Pred[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        vars__.emplace_back(cHatPred[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        vars__.emplace_back(ceHatPred[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        vars__.emplace_back(respHatPred[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        vars__.emplace_back(cObsCond[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        vars__.emplace_back(respObsCond[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        vars__.emplace_back(cObsPred[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        vars__.emplace_back(respObsPred[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nRandom; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= nId; ++sym2__) {
          vars__.emplace_back(
            rvalue(thetaPred,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())), "thetaPred"));
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= nCmt; ++sym2__) {
          vars__.emplace_back(
            rvalue(xPred,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())), "xPred"));}}
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        vars__.emplace_back(model_par_pred[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nRandom; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= nRandom; ++sym2__) {
          vars__.emplace_back(
            rvalue(rho,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())), "rho"));}}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= nRandom; ++sym2__) {
          vars__.emplace_back(
            rvalue(etaStdPred,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              "etaStdPred"));}}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  inline void transform_inits(const stan::io::var_context& context__,
                              std::vector<int>& params_i__,
                              std::vector<double>& vars__,
                              std::ostream* pstream__) const
    final {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double CLHat;
      CLHat = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      CLHat = context__.vals_r("CLHat")[(1 - 1)];
      double CLHat_free__;
      CLHat_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      CLHat_free__ = stan::math::lb_free(CLHat, 0);
      double VHat;
      VHat = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      VHat = context__.vals_r("VHat")[(1 - 1)];
      double VHat_free__;
      VHat_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      VHat_free__ = stan::math::lb_free(VHat, 0);
      double kaHat;
      kaHat = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      kaHat = context__.vals_r("kaHat")[(1 - 1)];
      double kaHat_free__;
      kaHat_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      kaHat_free__ = stan::math::lb_free(kaHat, (CLHat / VHat));
      double ke0Hat;
      ke0Hat = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      ke0Hat = context__.vals_r("ke0Hat")[(1 - 1)];
      double ke0Hat_free__;
      ke0Hat_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      ke0Hat_free__ = stan::math::lb_free(ke0Hat, 0);
      double E0Hat;
      E0Hat = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 5;
      E0Hat = context__.vals_r("E0Hat")[(1 - 1)];
      double E0Hat_free__;
      E0Hat_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 5;
      E0Hat_free__ = stan::math::lb_free(E0Hat, 0);
      double EmaxHat;
      EmaxHat = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 6;
      EmaxHat = context__.vals_r("EmaxHat")[(1 - 1)];
      double EmaxHat_free__;
      EmaxHat_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 6;
      EmaxHat_free__ = stan::math::lb_free(EmaxHat, 0);
      double EC50;
      EC50 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 7;
      EC50 = context__.vals_r("EC50")[(1 - 1)];
      double EC50_free__;
      EC50_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 7;
      EC50_free__ = stan::math::lb_free(EC50, 0);
      double gamma;
      gamma = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 8;
      gamma = context__.vals_r("gamma")[(1 - 1)];
      double gamma_free__;
      gamma_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 8;
      gamma_free__ = stan::math::lb_free(gamma, 0);
      Eigen::Matrix<double, -1, 1> omega;
      omega = Eigen::Matrix<double, -1, 1>(nRandom);
      stan::math::fill(omega, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> omega_flat__;
        current_statement__ = 9;
        assign(omega_flat__, nil_index_list(), context__.vals_r("omega"),
          "assigning variable omega_flat__");
        current_statement__ = 9;
        pos__ = 1;
        current_statement__ = 9;
        for (int sym1__ = 1; sym1__ <= nRandom; ++sym1__) {
          current_statement__ = 9;
          assign(omega, cons_list(index_uni(sym1__), nil_index_list()),
            omega_flat__[(pos__ - 1)], "assigning variable omega");
          current_statement__ = 9;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> omega_free__;
      omega_free__ = Eigen::Matrix<double, -1, 1>(nRandom);
      stan::math::fill(omega_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 9;
      for (int sym1__ = 1; sym1__ <= nRandom; ++sym1__) {
        current_statement__ = 9;
        assign(omega_free__, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(omega[(sym1__ - 1)], 0),
          "assigning variable omega_free__");}
      Eigen::Matrix<double, -1, -1> L;
      L = Eigen::Matrix<double, -1, -1>(nRandom, nRandom);
      stan::math::fill(L, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> L_flat__;
        current_statement__ = 10;
        assign(L_flat__, nil_index_list(), context__.vals_r("L"),
          "assigning variable L_flat__");
        current_statement__ = 10;
        pos__ = 1;
        current_statement__ = 10;
        for (int sym1__ = 1; sym1__ <= nRandom; ++sym1__) {
          current_statement__ = 10;
          for (int sym2__ = 1; sym2__ <= nRandom; ++sym2__) {
            current_statement__ = 10;
            assign(L,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              L_flat__[(pos__ - 1)], "assigning variable L");
            current_statement__ = 10;
            pos__ = (pos__ + 1);}}
      }
      Eigen::Matrix<double, -1, 1> L_free__;
      L_free__ = Eigen::Matrix<double, -1, 1>(((nRandom * (nRandom - 1)) / 2));
      stan::math::fill(L_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 10;
      assign(L_free__, nil_index_list(), stan::math::cholesky_corr_free(L),
        "assigning variable L_free__");
      double sigma;
      sigma = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 11;
      sigma = context__.vals_r("sigma")[(1 - 1)];
      double sigma_free__;
      sigma_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 11;
      sigma_free__ = stan::math::lb_free(sigma, 0);
      double sigmaPD;
      sigmaPD = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 12;
      sigmaPD = context__.vals_r("sigmaPD")[(1 - 1)];
      double sigmaPD_free__;
      sigmaPD_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 12;
      sigmaPD_free__ = stan::math::lb_free(sigmaPD, 0);
      Eigen::Matrix<double, -1, -1> etaStd;
      etaStd = Eigen::Matrix<double, -1, -1>(nRandom, nId);
      stan::math::fill(etaStd, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> etaStd_flat__;
        current_statement__ = 13;
        assign(etaStd_flat__, nil_index_list(), context__.vals_r("etaStd"),
          "assigning variable etaStd_flat__");
        current_statement__ = 13;
        pos__ = 1;
        current_statement__ = 13;
        for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
          current_statement__ = 13;
          for (int sym2__ = 1; sym2__ <= nRandom; ++sym2__) {
            current_statement__ = 13;
            assign(etaStd,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              etaStd_flat__[(pos__ - 1)], "assigning variable etaStd");
            current_statement__ = 13;
            pos__ = (pos__ + 1);}}
      }
      vars__.emplace_back(CLHat_free__);
      vars__.emplace_back(VHat_free__);
      vars__.emplace_back(kaHat_free__);
      vars__.emplace_back(ke0Hat_free__);
      vars__.emplace_back(E0Hat_free__);
      vars__.emplace_back(EmaxHat_free__);
      vars__.emplace_back(EC50_free__);
      vars__.emplace_back(gamma_free__);
      for (int sym1__ = 1; sym1__ <= nRandom; ++sym1__) {
        vars__.emplace_back(omega_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= ((nRandom * (nRandom - 1)) / 2);
           ++sym1__) { vars__.emplace_back(L_free__[(sym1__ - 1)]);}
      vars__.emplace_back(sigma_free__);
      vars__.emplace_back(sigmaPD_free__);
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= nRandom; ++sym2__) {
          vars__.emplace_back(
            rvalue(etaStd,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())), "etaStd"));}
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("CLHat");
    names__.emplace_back("VHat");
    names__.emplace_back("kaHat");
    names__.emplace_back("ke0Hat");
    names__.emplace_back("E0Hat");
    names__.emplace_back("EmaxHat");
    names__.emplace_back("EC50");
    names__.emplace_back("gamma");
    names__.emplace_back("omega");
    names__.emplace_back("L");
    names__.emplace_back("sigma");
    names__.emplace_back("sigmaPD");
    names__.emplace_back("etaStd");
    names__.emplace_back("thetaHat");
    names__.emplace_back("theta");
    names__.emplace_back("CL");
    names__.emplace_back("V");
    names__.emplace_back("ka");
    names__.emplace_back("ke0");
    names__.emplace_back("Emax");
    names__.emplace_back("E0");
    names__.emplace_back("cHat");
    names__.emplace_back("ceHat");
    names__.emplace_back("respHat");
    names__.emplace_back("cHatObs");
    names__.emplace_back("respHatObs");
    names__.emplace_back("model_par");
    names__.emplace_back("x");
    names__.emplace_back("CLPred");
    names__.emplace_back("VPred");
    names__.emplace_back("kaPred");
    names__.emplace_back("ke0Pred");
    names__.emplace_back("EmaxPred");
    names__.emplace_back("E0Pred");
    names__.emplace_back("cHatPred");
    names__.emplace_back("ceHatPred");
    names__.emplace_back("respHatPred");
    names__.emplace_back("cObsCond");
    names__.emplace_back("respObsCond");
    names__.emplace_back("cObsPred");
    names__.emplace_back("respObsPred");
    names__.emplace_back("thetaPred");
    names__.emplace_back("xPred");
    names__.emplace_back("model_par_pred");
    names__.emplace_back("rho");
    names__.emplace_back("etaStdPred");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const
    final {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nRandom)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nRandom),
                                             static_cast<size_t>(nRandom)});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nRandom),
                                             static_cast<size_t>(nId)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nRandom)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nId),
                                             static_cast<size_t>(nRandom)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nId)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nId)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nId)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nId)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nId)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nId)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nt)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nt)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nt)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nObsPK)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nObsPD)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(4)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nCmt),
                                             static_cast<size_t>(nt)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nId)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nId)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nId)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nId)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nId)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nId)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nt)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nt)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nt)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nt)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nt)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nt)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nt)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nId),
                                             static_cast<size_t>(nRandom)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nCmt),
                                             static_cast<size_t>(nt)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(4)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nRandom),
                                             static_cast<size_t>(nRandom)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nRandom),
                                             static_cast<size_t>(nId)});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "CLHat");
    param_names__.emplace_back(std::string() + "VHat");
    param_names__.emplace_back(std::string() + "kaHat");
    param_names__.emplace_back(std::string() + "ke0Hat");
    param_names__.emplace_back(std::string() + "E0Hat");
    param_names__.emplace_back(std::string() + "EmaxHat");
    param_names__.emplace_back(std::string() + "EC50");
    param_names__.emplace_back(std::string() + "gamma");
    for (int sym1__ = 1; sym1__ <= nRandom; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "omega" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= nRandom; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= nRandom; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "L" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    param_names__.emplace_back(std::string() + "sigma");
    param_names__.emplace_back(std::string() + "sigmaPD");
    for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= nRandom; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "etaStd" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= nRandom; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "thetaHat" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nRandom; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nId; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "CL" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "V" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "ka" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "ke0" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "Emax" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "E0" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "cHat" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "ceHat" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "respHat" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nObsPK; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "cHatObs" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nObsPD; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "respHatObs" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "model_par" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nCmt; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "x" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "CLPred" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "VPred" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "kaPred" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "ke0Pred" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "EmaxPred" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "E0Pred" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "cHatPred" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "ceHatPred" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "respHatPred" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "cObsCond" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "respObsCond" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "cObsPred" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "respObsPred" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nRandom; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nId; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "thetaPred" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nCmt; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "xPred" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "model_par_pred" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nRandom; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nRandom; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "rho" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nRandom; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "etaStdPred" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "CLHat");
    param_names__.emplace_back(std::string() + "VHat");
    param_names__.emplace_back(std::string() + "kaHat");
    param_names__.emplace_back(std::string() + "ke0Hat");
    param_names__.emplace_back(std::string() + "E0Hat");
    param_names__.emplace_back(std::string() + "EmaxHat");
    param_names__.emplace_back(std::string() + "EC50");
    param_names__.emplace_back(std::string() + "gamma");
    for (int sym1__ = 1; sym1__ <= nRandom; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "omega" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= ((nRandom * (nRandom - 1)) / 2); ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "L" + '.' + std::to_string(sym1__));
      }}
    param_names__.emplace_back(std::string() + "sigma");
    param_names__.emplace_back(std::string() + "sigmaPD");
    for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= nRandom; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "etaStd" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= nRandom; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "thetaHat" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nRandom; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nId; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "CL" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "V" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "ka" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "ke0" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "Emax" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "E0" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "cHat" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "ceHat" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "respHat" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nObsPK; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "cHatObs" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nObsPD; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "respHatObs" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "model_par" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nCmt; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "x" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "CLPred" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "VPred" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "kaPred" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "ke0Pred" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "EmaxPred" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "E0Pred" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "cHatPred" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "ceHatPred" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "respHatPred" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "cObsCond" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "respObsCond" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "cObsPred" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "respObsPred" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nRandom; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nId; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "thetaPred" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nCmt; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "xPred" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "model_par_pred" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= ((nRandom * (nRandom - 1)) / 2);
           ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "rho" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nId; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nRandom; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "etaStdPred" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"CLHat\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"VHat\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"kaHat\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"ke0Hat\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"E0Hat\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"EmaxHat\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"EC50\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gamma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"omega\",\"type\":{\"name\":\"vector\",\"length\":" << nRandom << "},\"block\":\"parameters\"},{\"name\":\"L\",\"type\":{\"name\":\"matrix\",\"rows\":" << nRandom << ",\"cols\":" << nRandom << "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigmaPD\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"etaStd\",\"type\":{\"name\":\"matrix\",\"rows\":" << nRandom << ",\"cols\":" << nId << "},\"block\":\"parameters\"},{\"name\":\"thetaHat\",\"type\":{\"name\":\"vector\",\"length\":" << nRandom << "},\"block\":\"transformed_parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"matrix\",\"rows\":" << nId << ",\"cols\":" << nRandom << "},\"block\":\"transformed_parameters\"},{\"name\":\"CL\",\"type\":{\"name\":\"array\",\"length\":" << nId << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"V\",\"type\":{\"name\":\"array\",\"length\":" << nId << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"ka\",\"type\":{\"name\":\"array\",\"length\":" << nId << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"ke0\",\"type\":{\"name\":\"array\",\"length\":" << nId << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"Emax\",\"type\":{\"name\":\"array\",\"length\":" << nId << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"E0\",\"type\":{\"name\":\"array\",\"length\":" << nId << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"cHat\",\"type\":{\"name\":\"vector\",\"length\":" << nt << "},\"block\":\"transformed_parameters\"},{\"name\":\"ceHat\",\"type\":{\"name\":\"vector\",\"length\":" << nt << "},\"block\":\"transformed_parameters\"},{\"name\":\"respHat\",\"type\":{\"name\":\"vector\",\"length\":" << nt << "},\"block\":\"transformed_parameters\"},{\"name\":\"cHatObs\",\"type\":{\"name\":\"vector\",\"length\":" << nObsPK << "},\"block\":\"transformed_parameters\"},{\"name\":\"respHatObs\",\"type\":{\"name\":\"vector\",\"length\":" << nObsPD << "},\"block\":\"transformed_parameters\"},{\"name\":\"model_par\",\"type\":{\"name\":\"array\",\"length\":" << 4 << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"x\",\"type\":{\"name\":\"matrix\",\"rows\":" << nCmt << ",\"cols\":" << nt << "},\"block\":\"transformed_parameters\"},{\"name\":\"CLPred\",\"type\":{\"name\":\"array\",\"length\":" << nId << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"VPred\",\"type\":{\"name\":\"array\",\"length\":" << nId << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"kaPred\",\"type\":{\"name\":\"array\",\"length\":" << nId << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"ke0Pred\",\"type\":{\"name\":\"array\",\"length\":" << nId << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"EmaxPred\",\"type\":{\"name\":\"array\",\"length\":" << nId << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"E0Pred\",\"type\":{\"name\":\"array\",\"length\":" << nId << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"cHatPred\",\"type\":{\"name\":\"vector\",\"length\":" << nt << "},\"block\":\"generated_quantities\"},{\"name\":\"ceHatPred\",\"type\":{\"name\":\"vector\",\"length\":" << nt << "},\"block\":\"generated_quantities\"},{\"name\":\"respHatPred\",\"type\":{\"name\":\"vector\",\"length\":" << nt << "},\"block\":\"generated_quantities\"},{\"name\":\"cObsCond\",\"type\":{\"name\":\"array\",\"length\":" << nt << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"respObsCond\",\"type\":{\"name\":\"array\",\"length\":" << nt << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"cObsPred\",\"type\":{\"name\":\"array\",\"length\":" << nt << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"respObsPred\",\"type\":{\"name\":\"array\",\"length\":" << nt << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"thetaPred\",\"type\":{\"name\":\"matrix\",\"rows\":" << nId << ",\"cols\":" << nRandom << "},\"block\":\"generated_quantities\"},{\"name\":\"xPred\",\"type\":{\"name\":\"matrix\",\"rows\":" << nCmt << ",\"cols\":" << nt << "},\"block\":\"generated_quantities\"},{\"name\":\"model_par_pred\",\"type\":{\"name\":\"array\",\"length\":" << 4 << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"rho\",\"type\":{\"name\":\"matrix\",\"rows\":" << nRandom << ",\"cols\":" << nRandom << "},\"block\":\"generated_quantities\"},{\"name\":\"etaStdPred\",\"type\":{\"name\":\"matrix\",\"rows\":" << nRandom << ",\"cols\":" << nId << "},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"CLHat\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"VHat\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"kaHat\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"ke0Hat\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"E0Hat\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"EmaxHat\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"EC50\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gamma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"omega\",\"type\":{\"name\":\"vector\",\"length\":" << nRandom << "},\"block\":\"parameters\"},{\"name\":\"L\",\"type\":{\"name\":\"vector\",\"length\":" << ((nRandom * (nRandom - 1)) / 2) << "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigmaPD\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"etaStd\",\"type\":{\"name\":\"matrix\",\"rows\":" << nRandom << ",\"cols\":" << nId << "},\"block\":\"parameters\"},{\"name\":\"thetaHat\",\"type\":{\"name\":\"vector\",\"length\":" << nRandom << "},\"block\":\"transformed_parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"matrix\",\"rows\":" << nId << ",\"cols\":" << nRandom << "},\"block\":\"transformed_parameters\"},{\"name\":\"CL\",\"type\":{\"name\":\"array\",\"length\":" << nId << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"V\",\"type\":{\"name\":\"array\",\"length\":" << nId << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"ka\",\"type\":{\"name\":\"array\",\"length\":" << nId << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"ke0\",\"type\":{\"name\":\"array\",\"length\":" << nId << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"Emax\",\"type\":{\"name\":\"array\",\"length\":" << nId << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"E0\",\"type\":{\"name\":\"array\",\"length\":" << nId << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"cHat\",\"type\":{\"name\":\"vector\",\"length\":" << nt << "},\"block\":\"transformed_parameters\"},{\"name\":\"ceHat\",\"type\":{\"name\":\"vector\",\"length\":" << nt << "},\"block\":\"transformed_parameters\"},{\"name\":\"respHat\",\"type\":{\"name\":\"vector\",\"length\":" << nt << "},\"block\":\"transformed_parameters\"},{\"name\":\"cHatObs\",\"type\":{\"name\":\"vector\",\"length\":" << nObsPK << "},\"block\":\"transformed_parameters\"},{\"name\":\"respHatObs\",\"type\":{\"name\":\"vector\",\"length\":" << nObsPD << "},\"block\":\"transformed_parameters\"},{\"name\":\"model_par\",\"type\":{\"name\":\"array\",\"length\":" << 4 << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"x\",\"type\":{\"name\":\"matrix\",\"rows\":" << nCmt << ",\"cols\":" << nt << "},\"block\":\"transformed_parameters\"},{\"name\":\"CLPred\",\"type\":{\"name\":\"array\",\"length\":" << nId << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"VPred\",\"type\":{\"name\":\"array\",\"length\":" << nId << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"kaPred\",\"type\":{\"name\":\"array\",\"length\":" << nId << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"ke0Pred\",\"type\":{\"name\":\"array\",\"length\":" << nId << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"EmaxPred\",\"type\":{\"name\":\"array\",\"length\":" << nId << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"E0Pred\",\"type\":{\"name\":\"array\",\"length\":" << nId << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"cHatPred\",\"type\":{\"name\":\"vector\",\"length\":" << nt << "},\"block\":\"generated_quantities\"},{\"name\":\"ceHatPred\",\"type\":{\"name\":\"vector\",\"length\":" << nt << "},\"block\":\"generated_quantities\"},{\"name\":\"respHatPred\",\"type\":{\"name\":\"vector\",\"length\":" << nt << "},\"block\":\"generated_quantities\"},{\"name\":\"cObsCond\",\"type\":{\"name\":\"array\",\"length\":" << nt << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"respObsCond\",\"type\":{\"name\":\"array\",\"length\":" << nt << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"cObsPred\",\"type\":{\"name\":\"array\",\"length\":" << nt << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"respObsPred\",\"type\":{\"name\":\"array\",\"length\":" << nt << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"thetaPred\",\"type\":{\"name\":\"matrix\",\"rows\":" << nId << ",\"cols\":" << nRandom << "},\"block\":\"generated_quantities\"},{\"name\":\"xPred\",\"type\":{\"name\":\"matrix\",\"rows\":" << nCmt << ",\"cols\":" << nt << "},\"block\":\"generated_quantities\"},{\"name\":\"model_par_pred\",\"type\":{\"name\":\"array\",\"length\":" << 4 << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"rho\",\"type\":{\"name\":\"vector\",\"length\":" << ((nRandom * (nRandom - 1)) / 2) << "},\"block\":\"generated_quantities\"},{\"name\":\"etaStdPred\",\"type\":{\"name\":\"matrix\",\"rows\":" << nRandom << ",\"cols\":" << nId << "},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = nullptr) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = nullptr) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__ = nullptr) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}

using stan_model = effectCpt2Ncp_effcpt_model_namespace::effectCpt2Ncp_effcpt_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif


